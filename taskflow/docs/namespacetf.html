<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>tf namespace | Taskflow QuickStart</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://taskflow.github.io"><img src="taskflow_logo.png" alt="" />Taskflow</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">QuickStart</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Handbook</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          tf <span class="m-thin">namespace</span>
        </h1>
        <p>taskflow namespace</p>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              Reference
              <ul>
                <li><a href="#nested-classes">Classes</a></li>
                <li><a href="#enum-members">Enums</a></li>
                <li><a href="#typedef-members">Typedefs</a></li>
                <li><a href="#func-members">Functions</a></li>
                <li><a href="#var-members">Variables</a></li>
              </ul>
            </li>
          </ul>
        </nav>
        <section id="nested-classes">
          <h2><a href="#nested-classes">Classes</a></h2>
          <dl class="m-doc">
            <dt>
              <div class="m-doc-template">template&lt;typename T, unsigned N = 2&gt;</div>
              class <a href="classtf_1_1SmallVector.html" class="m-doc">SmallVector</a>
            </dt>
            <dd>class to define a vector optimized for small array</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              struct <a href="structtf_1_1CachelineAligned.html" class="m-doc">CachelineAligned</a>
            </dt>
            <dd>struct to ensure cacheline-aligned storage for an object.</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              class <a href="classtf_1_1IndexRange.html" class="m-doc">IndexRange</a>
            </dt>
            <dd>class to create an index range of integral indices with a step size</dd>
            <dt>
              class <a href="classtf_1_1Graph.html" class="m-doc">Graph</a>
            </dt>
            <dd>class to create a graph object</dd>
            <dt>
              struct <a href="structtf_1_1TaskParams.html" class="m-doc">TaskParams</a>
            </dt>
            <dd>task parameters to use when creating an asynchronous task</dd>
            <dt>
              struct <a href="structtf_1_1DefaultTaskParams.html" class="m-doc">DefaultTaskParams</a>
            </dt>
            <dd>empty task parameter type for compile-time optimization</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              class <a href="classtf_1_1UnboundedTaskQueue.html" class="m-doc">UnboundedTaskQueue</a>
            </dt>
            <dd>class to create a lock-free unbounded work-stealing queue</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T, size_t LogSize = <a href="tsq_8hpp.html#a603f6f29f0f179ee85ecde7d5311a76e" class="m-doc">TF_<wbr />DEFAULT_<wbr />BOUNDED_<wbr />TASK_<wbr />QUEUE_<wbr />LOG_<wbr />SIZE</a>&gt;</div>
              class <a href="classtf_1_1BoundedTaskQueue.html" class="m-doc">BoundedTaskQueue</a>
            </dt>
            <dd>class to create a lock-free bounded work-stealing queue</dd>
            <dt>
              class <a href="classtf_1_1FlowBuilder.html" class="m-doc">FlowBuilder</a>
            </dt>
            <dd>class to build a task dependency graph</dd>
            <dt>
              class <a href="classtf_1_1Subflow.html" class="m-doc">Subflow</a>
            </dt>
            <dd>class to construct a subflow graph from the execution of a dynamic task</dd>
            <dt>
              class <a href="classtf_1_1Worker.html" class="m-doc">Worker</a>
            </dt>
            <dd>class to create a worker in an executor</dd>
            <dt>
              class <a href="classtf_1_1WorkerView.html" class="m-doc">WorkerView</a>
            </dt>
            <dd>class to create an immutable view of a worker</dd>
            <dt>
              class <a href="classtf_1_1WorkerInterface.html" class="m-doc">WorkerInterface</a>
            </dt>
            <dd>class to configure worker behavior in an executor</dd>
            <dt>
              class <a href="classtf_1_1Executor.html" class="m-doc">Executor</a>
            </dt>
            <dd>class to create an executor</dd>
            <dt>
              class <a href="classtf_1_1Task.html" class="m-doc">Task</a>
            </dt>
            <dd>class to create a task handle over a node in a taskflow graph</dd>
            <dt>
              class <a href="classtf_1_1TaskView.html" class="m-doc">TaskView</a>
            </dt>
            <dd>class to access task information from the observer interface</dd>
            <dt>
              class <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>
            </dt>
            <dd>class to create a dependent asynchronous task (async task)</dd>
            <dt>
              class <a href="classtf_1_1Runtime.html" class="m-doc">Runtime</a>
            </dt>
            <dd>class to include a runtime object in a task</dd>
            <dt>
              class <a href="classtf_1_1Semaphore.html" class="m-doc">Semaphore</a>
            </dt>
            <dd>class to create a semophore object for building a concurrency constraint</dd>
            <dt>
              class <a href="classtf_1_1Taskflow.html" class="m-doc">Taskflow</a>
            </dt>
            <dd>class to create a taskflow object</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              class <a href="classtf_1_1Future.html" class="m-doc">Future</a>
            </dt>
            <dd>class to access the result of an execution</dd>
            <dt>
              class <a href="classtf_1_1ObserverInterface.html" class="m-doc">ObserverInterface</a>
            </dt>
            <dd>class to derive an executor observer</dd>
            <dt>
              class <a href="classtf_1_1ChromeObserver.html" class="m-doc">ChromeObserver</a>
            </dt>
            <dd>class to create an observer based on Chrome tracing format</dd>
            <dt>
              class <a href="classtf_1_1TFProfObserver.html" class="m-doc">TFProfObserver</a>
            </dt>
            <dd>class to create an observer based on the built-in taskflow profiler format</dd>
            <dt>
              struct <a href="structtf_1_1DefaultClosureWrapper.html" class="m-doc">DefaultClosureWrapper</a>
            </dt>
            <dd>default closure wrapper that simply runs the given closure as is</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C = <a href="structtf_1_1DefaultClosureWrapper.html" class="m-doc">DefaultClosureWrapper</a>&gt;</div>
              class <a href="classtf_1_1PartitionerBase.html" class="m-doc">PartitionerBase</a>
            </dt>
            <dd>class to derive a partitioner for scheduling parallel algorithms</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C = <a href="structtf_1_1DefaultClosureWrapper.html" class="m-doc">DefaultClosureWrapper</a>&gt;</div>
              class <a href="classtf_1_1GuidedPartitioner.html" class="m-doc">GuidedPartitioner</a>
            </dt>
            <dd>class to construct a guided partitioner for scheduling parallel algorithms</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C = <a href="structtf_1_1DefaultClosureWrapper.html" class="m-doc">DefaultClosureWrapper</a>&gt;</div>
              class <a href="classtf_1_1DynamicPartitioner.html" class="m-doc">DynamicPartitioner</a>
            </dt>
            <dd>class to construct a dynamic partitioner for scheduling parallel algorithms</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C = <a href="structtf_1_1DefaultClosureWrapper.html" class="m-doc">DefaultClosureWrapper</a>&gt;</div>
              class <a href="classtf_1_1StaticPartitioner.html" class="m-doc">StaticPartitioner</a>
            </dt>
            <dd>class to construct a static partitioner for scheduling parallel algorithms</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C = <a href="structtf_1_1DefaultClosureWrapper.html" class="m-doc">DefaultClosureWrapper</a>&gt;</div>
              class <a href="classtf_1_1RandomPartitioner.html" class="m-doc">RandomPartitioner</a>
            </dt>
            <dd>class to construct a random partitioner for scheduling parallel algorithms</dd>
            <dt>
              class <a href="classtf_1_1Pipeflow.html" class="m-doc">Pipeflow</a>
            </dt>
            <dd>class to create a pipeflow object used by the pipe callable</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C = <a href="http://en.cppreference.com/w/cpp/utility/functional/function.html" class="m-doc-external">std::<wbr />function</a>&lt;void(<a href="classtf_1_1Pipeflow.html" class="m-doc">tf::<wbr />Pipeflow</a>&amp;)&gt;&gt;</div>
              class <a href="classtf_1_1Pipe.html" class="m-doc">Pipe</a>
            </dt>
            <dd>class to create a pipe object for a pipeline stage</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename... Ps&gt;</div>
              class <a href="classtf_1_1Pipeline.html" class="m-doc">Pipeline</a>
            </dt>
            <dd>class to create a pipeline scheduling framework</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P&gt;</div>
              class <a href="classtf_1_1ScalablePipeline.html" class="m-doc">ScalablePipeline</a>
            </dt>
            <dd>class to create a scalable pipeline object</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename Input, typename Output, typename C&gt;</div>
              class <a href="classtf_1_1DataPipe.html" class="m-doc">DataPipe</a>
            </dt>
            <dd>class to create a stage in a data-parallel pipeline</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename... Ps&gt;</div>
              class <a href="classtf_1_1DataPipeline.html" class="m-doc">DataPipeline</a>
            </dt>
            <dd>class to create a data-parallel pipeline scheduling framework</dd>
            <dt>
              class <a href="classtf_1_1cudaScopedDevice.html" class="m-doc">cudaScopedDevice</a>
            </dt>
            <dd>class to create an RAII-styled context switch</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              class <a href="classtf_1_1cudaDeviceAllocator.html" class="m-doc">cudaDeviceAllocator</a>
            </dt>
            <dd>class to create a CUDA device allocator</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              class <a href="classtf_1_1cudaUSMAllocator.html" class="m-doc">cudaUSMAllocator</a>
            </dt>
            <dd>class to create a unified shared memory (USM) allocator</dd>
            <dt>
              struct <a href="structtf_1_1cudaEventCreator.html" class="m-doc">cudaEventCreator</a>
            </dt>
            <dd>functor to create a <code>cudaEvent_t</code> object</dd>
            <dt>
              struct <a href="structtf_1_1cudaEventDeleter.html" class="m-doc">cudaEventDeleter</a>
            </dt>
            <dd>functor to delete a <code>cudaEvent_t</code> object</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename Creator, typename Deleter&gt;</div>
              class <a href="classtf_1_1cudaEventBase.html" class="m-doc">cudaEventBase</a>
            </dt>
            <dd>class to create a smart pointer wrapper for managing <code>cudaEvent_t</code></dd>
            <dt>
              struct <a href="structtf_1_1cudaStreamCreator.html" class="m-doc">cudaStreamCreator</a>
            </dt>
            <dd>functor to create a <code>cudaStream_t</code> object</dd>
            <dt>
              struct <a href="structtf_1_1cudaStreamDeleter.html" class="m-doc">cudaStreamDeleter</a>
            </dt>
            <dd>functor to delete a <code>cudaStream_t</code> object</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename Creator, typename Deleter&gt;</div>
              class <a href="classtf_1_1cudaStreamBase.html" class="m-doc">cudaStreamBase</a>
            </dt>
            <dd>class to create a smart pointer wrapper for managing <code>cudaStream_t</code></dd>
            <dt>
              class <a href="classtf_1_1cudaTask.html" class="m-doc">cudaTask</a>
            </dt>
            <dd>class to create a task handle of a CUDA <a href="classtf_1_1Graph.html" class="m-doc">Graph</a> node</dd>
            <dt>
              struct <a href="structtf_1_1cudaGraphCreator.html" class="m-doc">cudaGraphCreator</a>
            </dt>
            <dd>a functor for creating a CUDA graph</dd>
            <dt>
              struct <a href="structtf_1_1cudaGraphDeleter.html" class="m-doc">cudaGraphDeleter</a>
            </dt>
            <dd>a functor for deleting a CUDA graph</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename Creator, typename Deleter&gt;</div>
              class <a href="classtf_1_1cudaGraphBase.html" class="m-doc">cudaGraphBase</a>
            </dt>
            <dd>class to create a CUDA graph managed by C++ smart pointer</dd>
            <dt>
              struct <a href="structtf_1_1cudaGraphExecCreator.html" class="m-doc">cudaGraphExecCreator</a>
            </dt>
            <dd>a functor for creating an executable CUDA graph</dd>
            <dt>
              struct <a href="structtf_1_1cudaGraphExecDeleter.html" class="m-doc">cudaGraphExecDeleter</a>
            </dt>
            <dd>a functor for deleting an executable CUDA graph</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename Creator, typename Deleter&gt;</div>
              class <a href="classtf_1_1cudaGraphExecBase.html" class="m-doc">cudaGraphExecBase</a>
            </dt>
            <dd>class to create an executable CUDA graph managed by C++ smart pointer</dd>
          </dl>
        </section>
        <section id="enum-members">
          <h2><a href="#enum-members">Enums</a></h2>
          <dl class="m-doc">
            <dt>
              <span class="m-doc-wrap-bumper">enum class <a href="#a1355048578785a80414707ff308b395a" class="m-doc">TaskType</a>: int { </span><span class="m-doc-wrap"><a href="#a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" class="m-doc">PLACEHOLDER</a> = 0,
              <a href="#a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" class="m-doc">STATIC</a>,
              <a href="#a1355048578785a80414707ff308b395aae5f5cd9fe71ac064a678f27c7d539ae8" class="m-doc">RUNTIME</a>,
              <a href="#a1355048578785a80414707ff308b395aa46be697979903d784a70aeec45eb14ad" class="m-doc">SUBFLOW</a>,
              <a href="#a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" class="m-doc">CONDITION</a>,
              <a href="#a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" class="m-doc">MODULE</a>,
              <a href="#a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" class="m-doc">ASYNC</a>,
              <a href="#a1355048578785a80414707ff308b395aa0db45d2a4141101bdfe48e3314cfbca3" class="m-doc">UNDEFINED</a> }</span>
            </dt>
            <dd>enumeration of all task types</dd>
            <dt>
              <span class="m-doc-wrap-bumper">enum class <a href="#a192f7cb0fab2eb6f1c84f6046706435d" class="m-doc">ObserverType</a>: int { </span><span class="m-doc-wrap"><a href="#a192f7cb0fab2eb6f1c84f6046706435dac19bf39d8838d00eddb556775fa8acce" class="m-doc">TFPROF</a> = 0,
              <a href="#a192f7cb0fab2eb6f1c84f6046706435da37960509766262569d504f02a0ee986d" class="m-doc">CHROME</a>,
              <a href="#a192f7cb0fab2eb6f1c84f6046706435da0db45d2a4141101bdfe48e3314cfbca3" class="m-doc">UNDEFINED</a> }</span>
            </dt>
            <dd>enumeration of all observer types</dd>
            <dt>
              <span class="m-doc-wrap-bumper">enum class <a href="#a32d51425fa23cd0dc3518c16cf3bb6c0" class="m-doc">PartitionerType</a>: int { </span><span class="m-doc-wrap"><a href="#a32d51425fa23cd0dc3518c16cf3bb6c0afe6f99ef1ec99efbdc19a9786cf1facc" class="m-doc">STATIC</a>,
              <a href="#a32d51425fa23cd0dc3518c16cf3bb6c0a0fcc90da4811c877ba9f9c12f7d60bc9" class="m-doc">DYNAMIC</a> }</span>
            </dt>
            <dd>enumeration of all partitioner types</dd>
            <dt>
              <span class="m-doc-wrap-bumper">enum class <a href="#abb7a11e41fd457f69e7ff45d4c769564" class="m-doc">PipeType</a>: int { </span><span class="m-doc-wrap"><a href="#abb7a11e41fd457f69e7ff45d4c769564adf13a99b035d6f0bce4f44ab18eec8eb" class="m-doc">PARALLEL</a> = 1,
              <a href="#abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" class="m-doc">SERIAL</a> = 2 }</span>
            </dt>
            <dd>enumeration of all pipe types</dd>
          </dl>
        </section>
        <section id="typedef-members">
          <h2><a href="#typedef-members">Typedefs</a></h2>
          <dl class="m-doc">
            <dt>
              using <a href="#a8cff4bbd797dde4dfab096c3cc657833" class="m-doc">observer_stamp_t</a> = <a href="http://en.cppreference.com/w/cpp/chrono/time_point.html" class="m-doc-external">std::<wbr />chrono::<wbr />time_point</a>&lt;<a href="http://en.cppreference.com/w/cpp/chrono/steady_clock.html" class="m-doc-external">std::<wbr />chrono::<wbr />steady_clock</a>&gt;
            </dt>
            <dd>default time point type of observers</dd>
            <dt>
              using <a href="#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a> = <a href="classtf_1_1GuidedPartitioner.html" class="m-doc">GuidedPartitioner</a>&lt;&gt;
            </dt>
            <dd>default partitioner set to <a href="classtf_1_1GuidedPartitioner.html" class="m-doc">tf::<wbr />GuidedPartitioner</a></dd>
            <dt>
              using <a href="#a19f35245e6334fae46dccb73f27417bf" class="m-doc">cudaEvent</a> = <a href="classtf_1_1cudaEventBase.html" class="m-doc">cudaEventBase</a>&lt;<a href="structtf_1_1cudaEventCreator.html" class="m-doc">cudaEventCreator</a>, <a href="structtf_1_1cudaEventDeleter.html" class="m-doc">cudaEventDeleter</a>&gt;
            </dt>
            <dd>default smart pointer type to manage a <code>cudaEvent_t</code> object with unique ownership</dd>
            <dt>
              using <a href="#a45b31698cd7ee9a4dcd55465d1e8942a" class="m-doc">cudaStream</a> = <a href="classtf_1_1cudaStreamBase.html" class="m-doc">cudaStreamBase</a>&lt;<a href="structtf_1_1cudaStreamCreator.html" class="m-doc">cudaStreamCreator</a>, <a href="structtf_1_1cudaStreamDeleter.html" class="m-doc">cudaStreamDeleter</a>&gt;
            </dt>
            <dd>default smart pointer type to manage a <code>cudaStream_t</code> object with unique ownership</dd>
            <dt>
              using <a href="#ac76b07f7b7055967f6a2f1dc78b0978a" class="m-doc">cudaGraph</a> = <a href="classtf_1_1cudaGraphBase.html" class="m-doc">cudaGraphBase</a>&lt;<a href="structtf_1_1cudaGraphCreator.html" class="m-doc">cudaGraphCreator</a>, <a href="structtf_1_1cudaGraphDeleter.html" class="m-doc">cudaGraphDeleter</a>&gt;
            </dt>
            <dd>default smart pointer type to manage a <code>cudaGraph_t</code> object with unique ownership</dd>
            <dt>
              using <a href="#a21efbebd2a9b305f43dde90b7b837dc7" class="m-doc">cudaGraphExec</a> = <a href="classtf_1_1cudaGraphExecBase.html" class="m-doc">cudaGraphExecBase</a>&lt;<a href="structtf_1_1cudaGraphExecCreator.html" class="m-doc">cudaGraphExecCreator</a>, <a href="structtf_1_1cudaGraphExecDeleter.html" class="m-doc">cudaGraphExecDeleter</a>&gt;
            </dt>
            <dd>default smart pointer type to manage a <code>cudaGraphExec_t</code> object with unique ownership</dd>
          </dl>
        </section>
        <section id="func-members">
          <h2><a href="#func-members">Functions</a></h2>
          <dl class="m-doc">
            <dt>
              <div class="m-doc-template">template&lt;typename T, std::enable_if_t&lt;(std::is_unsigned_v&lt;std::decay_t&lt;T&gt;&gt; &amp;&amp; sizeof(T)==8), void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ae9682c3db0662fdf6d688a8b095c19ea" class="m-doc">next_pow2</a>(</span><span class="m-doc-wrap">T x) -&gt; T <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>rounds the given 64-bit unsigned integer to the nearest power of 2</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;std::decay_t&lt;T&gt;&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a8d48a5014f34a9f97aae5269c2367e38" class="m-doc">is_pow2</a>(</span><span class="m-doc-wrap">const T&amp; x) -&gt; bool <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>checks if the given number is a power of 2</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a8845f13b039ef9820087c9f467f6c734" class="m-doc">floor_log2</a>(</span><span class="m-doc-wrap">T n) -&gt; size_t <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>computes the floor of the base-2 logarithm of a number using count-leading-zeros (CTL).</dd>
            <dt id="a908e0f3faf873e897b3e1bafbd4bb876">
              <div class="m-doc-template">template&lt;size_t N&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a908e0f3faf873e897b3e1bafbd4bb876" class="m-doc-self">static_floor_log2</a>(</span><span class="m-doc-wrap">) -&gt; size_t <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>returns the floor of <code>log2(N)</code> at compile time</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename RandItr, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a0b2dc0c0c931b9b627fc0a148085fa5e" class="m-doc">median_of_three</a>(</span><span class="m-doc-wrap">RandItr l,
              RandItr m,
              RandItr r,
              C cmp) -&gt; RandItr</span>
            </dt>
            <dd>finds the median of three numbers pointed to by iterators using the given comparator</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename RandItr, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a5f9a989c8de663d3ee010cbc6de13c91" class="m-doc">pseudo_median_of_nine</a>(</span><span class="m-doc-wrap">RandItr beg,
              RandItr end,
              C cmp) -&gt; RandItr</span>
            </dt>
            <dd>finds the pseudo median of a range of items using a spread of nine numbers</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename Iter, typename Compare&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#a8d3fa9252b0da87bff1df912d0a591fe" class="m-doc">sort2</a>(</span><span class="m-doc-wrap">Iter a,
              Iter b,
              Compare comp)</span>
            </dt>
            <dd>sorts two elements of dereferenced iterators using the given comparison function</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename Iter, typename Compare&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#a86489af717270b8c9b657b347215ef0f" class="m-doc">sort3</a>(</span><span class="m-doc-wrap">Iter a,
              Iter b,
              Iter c,
              Compare comp)</span>
            </dt>
            <dd>Sorts three elements of dereferenced iterators using the given comparison function.</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a00b75b92482d883f06282d5181e6f6f9" class="m-doc">unique_id</a>(</span><span class="m-doc-wrap">) -&gt; T</span>
            </dt>
            <dd>generates a program-wide unique ID of the given type in a thread-safe manner</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#a5002af34dc323ff28e87ae83203b2c36" class="m-doc">atomic_max</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/atomic/atomic.html" class="m-doc-external">std::<wbr />atomic</a>&lt;T&gt;&amp; v,
              const T&amp; max_v) <span class="m-label m-flat m-success">noexcept</span></span>
            </dt>
            <dd>updates an atomic variable with the maximum value</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#a512ffa0d24a237b098f5de656b8bdcb0" class="m-doc">atomic_min</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/atomic/atomic.html" class="m-doc-external">std::<wbr />atomic</a>&lt;T&gt;&amp; v,
              const T&amp; min_v) <span class="m-label m-flat m-success">noexcept</span></span>
            </dt>
            <dd>updates an atomic variable with the minimum value</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a3f8e89aebc29d42259157723c874954d" class="m-doc">seed</a>(</span><span class="m-doc-wrap">) -&gt; T <span class="m-label m-flat m-success">noexcept</span></span>
            </dt>
            <dd>generates a random seed based on the current system clock</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T, typename = std::enable_if_t&lt;std::is_unsigned_v&lt;T&gt;&gt;&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a0b8e46604b2d40f0a7f2cc4796003d49" class="m-doc">ctz</a>(</span><span class="m-doc-wrap">T x) -&gt; auto</span>
            </dt>
            <dd>counts the number of trailing zeros in an integer.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a15c9131faea47635a65e6caf21b6f868" class="m-doc">coprime</a>(</span><span class="m-doc-wrap">size_t N) -&gt; size_t <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>computes a coprime of a given number</dd>
            <dt>
              <div class="m-doc-template">template&lt;size_t N&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#af96bfc2b11d1743ca2d344e08a484d5e" class="m-doc">make_coprime_lut</a>(</span><span class="m-doc-wrap">) -&gt; <a href="http://en.cppreference.com/w/cpp/container/array.html" class="m-doc-external">std::<wbr />array</a>&lt;size_t, N&gt; <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>generates a compile-time array of coprimes for numbers from 0 to N-1</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#abbef08f01c467fd4f746c3247af892bc" class="m-doc">get_env</a>(</span><span class="m-doc-wrap">const <a href="http://en.cppreference.com/w/cpp/string/basic_string.html" class="m-doc-external">std::<wbr />string</a>&amp; str) -&gt; <a href="http://en.cppreference.com/w/cpp/string/basic_string.html" class="m-doc-external">std::<wbr />string</a></span>
            </dt>
            <dd>retrieves the value of an environment variable</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#adc9815b9f96b796675ba939078d25413" class="m-doc">has_env</a>(</span><span class="m-doc-wrap">const <a href="http://en.cppreference.com/w/cpp/string/basic_string.html" class="m-doc-external">std::<wbr />string</a>&amp; str) -&gt; bool</span>
            </dt>
            <dd>checks whether an environment variable is defined</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#aef9af2433294beb7d41680e5b33eafdd" class="m-doc">pause</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd></dd>
            <dt id="ae9b372cf6337d0fd563fecc59a1915cc">
              <span class="m-doc-wrap-bumper">void <a href="#ae9b372cf6337d0fd563fecc59a1915cc" class="m-doc-self">pause</a>(</span><span class="m-doc-wrap">size_t count)</span>
            </dt>
            <dd>pause CPU for a specified number of iterations</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#a3abe09ef55c4f46e64ba88bff175c4f6" class="m-doc">spin_until</a>(</span><span class="m-doc-wrap">P&amp;&amp; predicate)</span>
            </dt>
            <dd>spins until the given predicate becomes true</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename S&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a5643bf94c64370ee721692e3e6d9dc80" class="m-doc">is_index_range_invalid</a>(</span><span class="m-doc-wrap">B beg,
              E end,
              S step) -&gt; std::enable_if_t&lt;std::is_integral_v&lt;std::decay_t&lt;B&gt;&gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;E&gt;&gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;S&gt;&gt;, bool&gt; <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>checks if the given index range is invalid</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename S&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a02a73acf6a05a3a4c673068daaad866f" class="m-doc">distance</a>(</span><span class="m-doc-wrap">B beg,
              E end,
              S step) -&gt; std::enable_if_t&lt;std::is_integral_v&lt;std::decay_t&lt;B&gt;&gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;E&gt;&gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;S&gt;&gt;, size_t&gt; <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>calculates the number of iterations in the given index range</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T, typename... ArgsT&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a97960776f3c78e18e68c79c336ba4f2d" class="m-doc">make_worker_interface</a>(</span><span class="m-doc-wrap">ArgsT &amp;&amp; ... args) -&gt; <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html" class="m-doc-external">std::<wbr />unique_ptr</a>&lt;T&gt;</span>
            </dt>
            <dd>helper function to create an instance derived from <a href="classtf_1_1WorkerInterface.html" class="m-doc">tf::<wbr />WorkerInterface</a></dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a9ca58dc6c666698cc7373eb0262140ef" class="m-doc">to_string</a>(</span><span class="m-doc-wrap"><a href="#a1355048578785a80414707ff308b395a" class="m-doc">TaskType</a> type) -&gt; const char*</span>
            </dt>
            <dd>convert a task type to a human-readable string</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#ad216aea4d0f648e149e47374ad015b1f" class="m-doc">operator&lt;&lt;</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html" class="m-doc-external">std::<wbr />ostream</a>&amp; os,
              const <a href="classtf_1_1Task.html" class="m-doc">Task</a>&amp; task) -&gt; <a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html" class="m-doc-external">std::<wbr />ostream</a>&amp;</span>
            </dt>
            <dd>overload of ostream inserter operator for <a href="classtf_1_1Task.html" class="m-doc">Task</a></dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#aa3fc0699b2c2b8f2f76bb39f91be1acb" class="m-doc">to_string</a>(</span><span class="m-doc-wrap"><a href="#a192f7cb0fab2eb6f1c84f6046706435d" class="m-doc">ObserverType</a> type) -&gt; const char*</span>
            </dt>
            <dd>convert an observer type to a human-readable string</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename Input, typename Output, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a8975fa5762088789adb0b60f38208309" class="m-doc">make_data_pipe</a>(</span><span class="m-doc-wrap"><a href="#abb7a11e41fd457f69e7ff45d4c769564" class="m-doc">PipeType</a> d,
              C&amp;&amp; callable) -&gt; auto</span>
            </dt>
            <dd>function to construct a data pipe (<a href="classtf_1_1DataPipe.html" class="m-doc">tf::<wbr />DataPipe</a>)</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#aae281ad3b89a5c421a1f4058f425e54c" class="m-doc">make_module_task</a>(</span><span class="m-doc-wrap">T&amp;&amp; target) -&gt; auto</span>
            </dt>
            <dd>creates a module task using the given target</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#abffa70155a5f160b7ceb86ee52ab2136" class="m-doc">cuda_get_num_devices</a>(</span><span class="m-doc-wrap">) -&gt; size_t</span>
            </dt>
            <dd>queries the number of available devices</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a235f5a9ce203d538eec1f4114221d473" class="m-doc">cuda_get_device</a>(</span><span class="m-doc-wrap">) -&gt; int</span>
            </dt>
            <dd>gets the current device associated with the caller thread</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#ade2938289fa49aafc9b2b7b090deaa22" class="m-doc">cuda_set_device</a>(</span><span class="m-doc-wrap">int id)</span>
            </dt>
            <dd>switches to a given device context</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a403b679694f4c85c857163b47e84d566" class="m-doc">cuda_get_device_property</a>(</span><span class="m-doc-wrap">int i,
              cudaDeviceProp&amp; p)</span>
            </dt>
            <dd>obtains the device property</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a0e82b8a929e12349240276e34ec9f8c8" class="m-doc">cuda_get_device_property</a>(</span><span class="m-doc-wrap">int i) -&gt; cudaDeviceProp</span>
            </dt>
            <dd>obtains the device property</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#aff8073c78daa741df76b530a0e602287" class="m-doc">cuda_dump_device_property</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html" class="m-doc-external">std::<wbr />ostream</a>&amp; os,
              const cudaDeviceProp&amp; p)</span>
            </dt>
            <dd>dumps the device property</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#abf813f7ac4249d1b752d1b724f970deb" class="m-doc">cuda_get_device_max_threads_per_block</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the maximum threads per block on a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#af8184bb128c446fe383315f3dc15acf6" class="m-doc">cuda_get_device_max_x_dim_per_block</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the maximum x-dimension per block on a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a9aba5f29135b9da29015c2a367ab1d70" class="m-doc">cuda_get_device_max_y_dim_per_block</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the maximum y-dimension per block on a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a5580f59e633625b2f344bbf477d17c2f" class="m-doc">cuda_get_device_max_z_dim_per_block</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the maximum z-dimension per block on a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a597579c8a9ab31244418e30a5aa74491" class="m-doc">cuda_get_device_max_x_dim_per_grid</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the maximum x-dimension per grid on a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a91d5c1609a7542949dd56d08b7c4c645" class="m-doc">cuda_get_device_max_y_dim_per_grid</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the maximum y-dimension per grid on a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a0373e32a20c7fc90c4f0461ee41bb918" class="m-doc">cuda_get_device_max_z_dim_per_grid</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the maximum z-dimension per grid on a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#aeca46ac171c4941a75aafddfe7546bfa" class="m-doc">cuda_get_device_max_shm_per_block</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the maximum shared memory size in bytes per block on a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#aea1b2af1073496f047d6fb9984cff4f1" class="m-doc">cuda_get_device_warp_size</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the warp size on a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a1fb03793a6b8705026b80ef87599d4d5" class="m-doc">cuda_get_device_compute_capability_major</a>(</span><span class="m-doc-wrap">int d) -&gt; int</span>
            </dt>
            <dd>queries the major number of compute capability of a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a71f5177665f4f7e18984ccc57d625602" class="m-doc">cuda_get_device_compute_capability_minor</a>(</span><span class="m-doc-wrap">int d) -&gt; int</span>
            </dt>
            <dd>queries the minor number of compute capability of a device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#ad389294b4d1c14219d8d098f796e27c5" class="m-doc">cuda_get_device_unified_addressing</a>(</span><span class="m-doc-wrap">int d) -&gt; bool</span>
            </dt>
            <dd>queries if the device supports unified addressing</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a43ac57f0eca3aa83c04bec3c4da9ab82" class="m-doc">cuda_get_driver_version</a>(</span><span class="m-doc-wrap">) -&gt; int</span>
            </dt>
            <dd>queries the latest CUDA version (1000 * major + 10 * minor) supported by the driver</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a31258ad089c6f847c8cd636cd72d6949" class="m-doc">cuda_get_runtime_version</a>(</span><span class="m-doc-wrap">) -&gt; int</span>
            </dt>
            <dd>queries the CUDA <a href="classtf_1_1Runtime.html" class="m-doc">Runtime</a> version (1000 * major + 10 * minor)</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a1effcf929b7e488925f9e12d74c8c62b" class="m-doc">cuda_get_free_mem</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the free memory (expensive call)</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a58bbc8d5d955582d6b5f7fdac51d010b" class="m-doc">cuda_get_total_mem</a>(</span><span class="m-doc-wrap">int d) -&gt; size_t</span>
            </dt>
            <dd>queries the total available memory (expensive call)</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a6f04fd3168c45eeb2dffb223e5c81e45" class="m-doc">cuda_malloc_device</a>(</span><span class="m-doc-wrap">size_t N,
              int d) -&gt; T*</span>
            </dt>
            <dd>allocates memory on the given device for holding <code>N</code> elements of type <code>T</code></dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ab9b68b8f4336f13b190d573969cb1cf7" class="m-doc">cuda_malloc_device</a>(</span><span class="m-doc-wrap">size_t N) -&gt; T*</span>
            </dt>
            <dd>allocates memory on the current device associated with the caller</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a8eed05685b030fc44703213a4ef86f11" class="m-doc">cuda_malloc_shared</a>(</span><span class="m-doc-wrap">size_t N) -&gt; T*</span>
            </dt>
            <dd>allocates shared memory for holding <code>N</code> elements of type <code>T</code></dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#ac7a8fe7456b888d6072ba94783c5003c" class="m-doc">cuda_free</a>(</span><span class="m-doc-wrap">T* ptr,
              int d)</span>
            </dt>
            <dd>frees memory on the GPU device</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#ae174a3a49b91ef21554dac16806f0d72" class="m-doc">cuda_free</a>(</span><span class="m-doc-wrap">T* ptr)</span>
            </dt>
            <dd>frees memory on the GPU device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#aa4266474b921f8ed7d9ec8071fded2a4" class="m-doc">cuda_memcpy_async</a>(</span><span class="m-doc-wrap">cudaStream_t stream,
              void* dst,
              const void* src,
              size_t count)</span>
            </dt>
            <dd>copies data between host and device asynchronously through a stream</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a6615554d2954e895755411ee444d9760" class="m-doc">cuda_memset_async</a>(</span><span class="m-doc-wrap">cudaStream_t stream,
              void* devPtr,
              int value,
              size_t count)</span>
            </dt>
            <dd>initializes or sets GPU memory to the given value byte by byte</dd>
            <dt id="aebe9b7a5647bec130362384b5ef12e6f">
              <div class="m-doc-template">template&lt;typename T, std::enable_if_t&lt;!std::is_same_v&lt;T, void&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#aebe9b7a5647bec130362384b5ef12e6f" class="m-doc-self">cuda_get_copy_parms</a>(</span><span class="m-doc-wrap">T* tgt,
              const T* src,
              size_t num) -&gt; cudaMemcpy3DParms</span>
            </dt>
            <dd>gets the memcpy node parameter of a copy task</dd>
            <dt id="a6d7fe7b199f0264b24a831100083f813">
              <span class="m-doc-wrap-bumper">auto <a href="#a6d7fe7b199f0264b24a831100083f813" class="m-doc-self">cuda_get_memcpy_parms</a>(</span><span class="m-doc-wrap">void* tgt,
              const void* src,
              size_t bytes) -&gt; cudaMemcpy3DParms</span>
            </dt>
            <dd>gets the memcpy node parameter of a memcpy task (untyped)</dd>
            <dt id="abdd529e729947d7b3123de89e43eb871">
              <span class="m-doc-wrap-bumper">auto <a href="#abdd529e729947d7b3123de89e43eb871" class="m-doc-self">cuda_get_memset_parms</a>(</span><span class="m-doc-wrap">void* dst,
              int ch,
              size_t count) -&gt; cudaMemsetParams</span>
            </dt>
            <dd>gets the memset node parameter of a memcpy task (untyped)</dd>
            <dt id="abf3eeb8a29df53ea51239159ebb08431">
              <div class="m-doc-template">template&lt;typename T, std::enable_if_t&lt;is_pod_v&lt;T&gt; &amp;&amp; (sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#abf3eeb8a29df53ea51239159ebb08431" class="m-doc-self">cuda_get_fill_parms</a>(</span><span class="m-doc-wrap">T* dst,
              T value,
              size_t count) -&gt; cudaMemsetParams</span>
            </dt>
            <dd>gets the memset node parameter of a fill task (typed)</dd>
            <dt id="a2e7a47a53034abe3218bcc583b0e9a56">
              <div class="m-doc-template">template&lt;typename T, std::enable_if_t&lt;is_pod_v&lt;T&gt; &amp;&amp; (sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a2e7a47a53034abe3218bcc583b0e9a56" class="m-doc-self">cuda_get_zero_parms</a>(</span><span class="m-doc-wrap">T* dst,
              size_t count) -&gt; cudaMemsetParams</span>
            </dt>
            <dd>gets the memset node parameter of a zero task (typed)</dd>
            <dt id="a8c9a4702aab3ce76a55c62ec276cd9fc">
              <span class="m-doc-wrap-bumper">auto <a href="#a8c9a4702aab3ce76a55c62ec276cd9fc" class="m-doc-self">cuda_graph_get_num_root_nodes</a>(</span><span class="m-doc-wrap">cudaGraph_t graph) -&gt; size_t</span>
            </dt>
            <dd>queries the number of root nodes in a native CUDA graph</dd>
            <dt id="a874ee3b3ee52d7cf6b6a7cc13859365f">
              <span class="m-doc-wrap-bumper">auto <a href="#a874ee3b3ee52d7cf6b6a7cc13859365f" class="m-doc-self">cuda_graph_get_num_nodes</a>(</span><span class="m-doc-wrap">cudaGraph_t graph) -&gt; size_t</span>
            </dt>
            <dd>queries the number of nodes in a native CUDA graph</dd>
            <dt id="a8fc7af3adc7dd7e646bd5275d8ae3f56">
              <span class="m-doc-wrap-bumper">auto <a href="#a8fc7af3adc7dd7e646bd5275d8ae3f56" class="m-doc-self">cuda_graph_get_num_edges</a>(</span><span class="m-doc-wrap">cudaGraph_t graph) -&gt; size_t</span>
            </dt>
            <dd>queries the number of edges in a native CUDA graph</dd>
            <dt id="ad5459c5551b8416d586bbbbac34a4e33">
              <span class="m-doc-wrap-bumper">auto <a href="#ad5459c5551b8416d586bbbbac34a4e33" class="m-doc-self">cuda_graph_get_nodes</a>(</span><span class="m-doc-wrap">cudaGraph_t graph) -&gt; <a href="http://en.cppreference.com/w/cpp/container/vector.html" class="m-doc-external">std::<wbr />vector</a>&lt;cudaGraphNode_t&gt;</span>
            </dt>
            <dd>acquires the nodes in a native CUDA graph</dd>
            <dt id="afee3e3a745757ec5b6ae36e2b0b0808d">
              <span class="m-doc-wrap-bumper">auto <a href="#afee3e3a745757ec5b6ae36e2b0b0808d" class="m-doc-self">cuda_graph_get_root_nodes</a>(</span><span class="m-doc-wrap">cudaGraph_t graph) -&gt; <a href="http://en.cppreference.com/w/cpp/container/vector.html" class="m-doc-external">std::<wbr />vector</a>&lt;cudaGraphNode_t&gt;</span>
            </dt>
            <dd>acquires the root nodes in a native CUDA graph</dd>
            <dt id="a007dfebb3ef1ab54da66cdd604494b38">
              <span class="m-doc-wrap-bumper">auto <a href="#a007dfebb3ef1ab54da66cdd604494b38" class="m-doc-self">cuda_graph_get_edges</a>(</span><span class="m-doc-wrap">cudaGraph_t graph) -&gt; <a href="http://en.cppreference.com/w/cpp/container/vector.html" class="m-doc-external">std::<wbr />vector</a>&lt;<a href="http://en.cppreference.com/w/cpp/utility/pair.html" class="m-doc-external">std::<wbr />pair</a>&lt;cudaGraphNode_t, cudaGraphNode_t&gt;&gt;</span>
            </dt>
            <dd>acquires the edges in a native CUDA graph</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#afb8f9fd1a826738ea95b4cf224c65cb0" class="m-doc">cuda_get_graph_node_type</a>(</span><span class="m-doc-wrap">cudaGraphNode_t node) -&gt; cudaGraphNodeType</span>
            </dt>
            <dd>queries the type of a native CUDA graph node</dd>
            <dt id="a70a7cb15356a204af1b73b4ac0bbc64a">
              <span class="m-doc-wrap-bumper">auto <a href="#a70a7cb15356a204af1b73b4ac0bbc64a" class="m-doc-self">to_string</a>(</span><span class="m-doc-wrap">cudaGraphNodeType type) -&gt; const char* <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>convert a cuda_task type to a human-readable string</dd>
            <dt id="a9cca69f61d792afb3ad501b703d795c1">
              <span class="m-doc-wrap-bumper">auto <a href="#a9cca69f61d792afb3ad501b703d795c1" class="m-doc-self">operator&lt;&lt;</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html" class="m-doc-external">std::<wbr />ostream</a>&amp; os,
              const <a href="classtf_1_1cudaTask.html" class="m-doc">cudaTask</a>&amp; ct) -&gt; <a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html" class="m-doc-external">std::<wbr />ostream</a>&amp;</span>
            </dt>
            <dd>overload of ostream inserter operator for <a href="classtf_1_1cudaTask.html" class="m-doc">cudaTask</a></dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a30fa078dcf625e9eada5a95af1467588" class="m-doc">version</a>(</span><span class="m-doc-wrap">) -&gt; const char* <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>queries the version information in a string format <code>major.minor.patch</code></dd>
          </dl>
        </section>
        <section id="var-members">
          <h2><a href="#var-members">Variables</a></h2>
          <dl class="m-doc">
            <dt>
              <div class="m-doc-template">template&lt;typename P&gt;</div>
              bool <a href="#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_task_params_v</a> <span class="m-label m-flat m-primary">constexpr</span>
            </dt>
            <dd>determines if the given type is a task parameter type</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              bool <a href="#aea3945d9b15c96a72540ea4fe61947e7" class="m-doc">has_graph_v</a> <span class="m-label m-flat m-primary">constexpr</span>
            </dt>
            <dd>determines if the given type has a member function <code><a href="classtf_1_1Graph.html" class="m-doc">Graph</a>&amp; graph()</code></dd>
            <dt>
              <a href="http://en.cppreference.com/w/cpp/container/array.html" class="m-doc-external">std::<wbr />array</a>&lt;<a href="#a1355048578785a80414707ff308b395a" class="m-doc">TaskType</a>, 7&gt; <a href="#a3d823d8776745f3348dc87bba2fcc91b" class="m-doc">TASK_TYPES</a> <span class="m-label m-flat m-primary">constexpr</span>
            </dt>
            <dd>array of all task types (used for iterating task types)</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C&gt;</div>
              bool <a href="#a11fc9c98eb3a0d3a9aa55598b1f4d614" class="m-doc">is_static_task_v</a> <span class="m-label m-flat m-primary">constexpr</span>
            </dt>
            <dd>determines if a callable is a static task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C&gt;</div>
              bool <a href="#aefeb96086f4a99f0e58a0f321012a52c" class="m-doc">is_subflow_task_v</a> <span class="m-label m-flat m-primary">constexpr</span>
            </dt>
            <dd>determines if a callable is a subflow task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C&gt;</div>
              bool <a href="#af3d94f0be0f7b49e195c4e92737b1f85" class="m-doc">is_runtime_task_v</a> <span class="m-label m-flat m-primary">constexpr</span>
            </dt>
            <dd>determines if a callable is a runtime task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C&gt;</div>
              bool <a href="#a00ca2fc2de0e679a7d9b8039340343df" class="m-doc">is_condition_task_v</a> <span class="m-label m-flat m-primary">constexpr</span>
            </dt>
            <dd>determines if a callable is a condition task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C&gt;</div>
              bool <a href="#a78c40dc8776735b0f2c27cd446481aff" class="m-doc">is_multi_condition_task_v</a> <span class="m-label m-flat m-primary">constexpr</span>
            </dt>
            <dd>determines if a callable is a multi-condition task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P&gt;</div>
              bool <a href="#a73c20705fc54763f195a00b6e626e301" class="m-doc">is_partitioner_v</a> <span class="m-label m-flat m-primary">constexpr</span>
            </dt>
            <dd>determines if a type is a partitioner</dd>
          </dl>
        </section>
        <section>
          <h2>Enum documentation</h2>
          <section class="m-doc-details" id="a1355048578785a80414707ff308b395a"><div>
            <h3>
              enum class tf::<wbr /><a href="#a1355048578785a80414707ff308b395a" class="m-doc-self">TaskType</a>: int
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="task_8hpp.html">&lt;taskflow/core/task.hpp&gt;</a></div>
            </h3>
            <p>enumeration of all task types</p>
            <table class="m-table m-fullwidth m-flat m-doc">
              <thead><tr><th style="width: 1%">Enumerators</th><th></th></tr></thead>
              <tbody>
                <tr>
                  <td><a href="#a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" class="m-doc-self" id="a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842">PLACEHOLDER</a></td>
                  <td>
                  <p>placeholder task type</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" class="m-doc-self" id="a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc">STATIC</a></td>
                  <td>
                  <p>static task type</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#a1355048578785a80414707ff308b395aae5f5cd9fe71ac064a678f27c7d539ae8" class="m-doc-self" id="a1355048578785a80414707ff308b395aae5f5cd9fe71ac064a678f27c7d539ae8">RUNTIME</a></td>
                  <td>
                  <p>runtime task type</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#a1355048578785a80414707ff308b395aa46be697979903d784a70aeec45eb14ad" class="m-doc-self" id="a1355048578785a80414707ff308b395aa46be697979903d784a70aeec45eb14ad">SUBFLOW</a></td>
                  <td>
                  <p>dynamic (subflow) task type</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" class="m-doc-self" id="a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac">CONDITION</a></td>
                  <td>
                  <p>condition task type</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" class="m-doc-self" id="a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69">MODULE</a></td>
                  <td>
                  <p>module task type</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" class="m-doc-self" id="a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96">ASYNC</a></td>
                  <td>
                  <p>asynchronous task type</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#a1355048578785a80414707ff308b395aa0db45d2a4141101bdfe48e3314cfbca3" class="m-doc-self" id="a1355048578785a80414707ff308b395aa0db45d2a4141101bdfe48e3314cfbca3">UNDEFINED</a></td>
                  <td>
                  <p>undefined task type (for internal use only)</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-doc-details" id="a192f7cb0fab2eb6f1c84f6046706435d"><div>
            <h3>
              enum class tf::<wbr /><a href="#a192f7cb0fab2eb6f1c84f6046706435d" class="m-doc-self">ObserverType</a>: int
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="observer_8hpp.html">&lt;taskflow/core/observer.hpp&gt;</a></div>
            </h3>
            <p>enumeration of all observer types</p>
          </div></section>
          <section class="m-doc-details" id="a32d51425fa23cd0dc3518c16cf3bb6c0"><div>
            <h3>
              enum class tf::<wbr /><a href="#a32d51425fa23cd0dc3518c16cf3bb6c0" class="m-doc-self">PartitionerType</a>: int
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="partitioner_8hpp.html">&lt;taskflow/algorithm/partitioner.hpp&gt;</a></div>
            </h3>
            <p>enumeration of all partitioner types</p>
            <table class="m-table m-fullwidth m-flat m-doc">
              <thead><tr><th style="width: 1%">Enumerators</th><th></th></tr></thead>
              <tbody>
                <tr>
                  <td><a href="#a32d51425fa23cd0dc3518c16cf3bb6c0afe6f99ef1ec99efbdc19a9786cf1facc" class="m-doc-self" id="a32d51425fa23cd0dc3518c16cf3bb6c0afe6f99ef1ec99efbdc19a9786cf1facc">STATIC</a></td>
                  <td>
                  <p>static partitioner type</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#a32d51425fa23cd0dc3518c16cf3bb6c0a0fcc90da4811c877ba9f9c12f7d60bc9" class="m-doc-self" id="a32d51425fa23cd0dc3518c16cf3bb6c0a0fcc90da4811c877ba9f9c12f7d60bc9">DYNAMIC</a></td>
                  <td>
                  <p>dynamic partitioner type</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-doc-details" id="abb7a11e41fd457f69e7ff45d4c769564"><div>
            <h3>
              enum class tf::<wbr /><a href="#abb7a11e41fd457f69e7ff45d4c769564" class="m-doc-self">PipeType</a>: int
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="pipeline_8hpp.html">&lt;taskflow/algorithm/pipeline.hpp&gt;</a></div>
            </h3>
            <p>enumeration of all pipe types</p>
            <table class="m-table m-fullwidth m-flat m-doc">
              <thead><tr><th style="width: 1%">Enumerators</th><th></th></tr></thead>
              <tbody>
                <tr>
                  <td><a href="#abb7a11e41fd457f69e7ff45d4c769564adf13a99b035d6f0bce4f44ab18eec8eb" class="m-doc-self" id="abb7a11e41fd457f69e7ff45d4c769564adf13a99b035d6f0bce4f44ab18eec8eb">PARALLEL</a></td>
                  <td>
                  <p>parallel type</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" class="m-doc-self" id="abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0">SERIAL</a></td>
                  <td>
                  <p>serial type</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div></section>
        </section>
        <section>
          <h2>Typedef documentation</h2>
          <section class="m-doc-details" id="a8cff4bbd797dde4dfab096c3cc657833"><div>
            <h3>
              using tf::<wbr /><a href="#a8cff4bbd797dde4dfab096c3cc657833" class="m-doc-self">observer_stamp_t</a> = <a href="http://en.cppreference.com/w/cpp/chrono/time_point.html" class="m-doc-external">std::<wbr />chrono::<wbr />time_point</a>&lt;<a href="http://en.cppreference.com/w/cpp/chrono/steady_clock.html" class="m-doc-external">std::<wbr />chrono::<wbr />steady_clock</a>&gt;
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="observer_8hpp.html">&lt;taskflow/core/observer.hpp&gt;</a></div>
            </h3>
            <p>default time point type of observers</p>
          </div></section>
          <section class="m-doc-details" id="a66b72776c788898aee9e132b0ea9b405"><div>
            <h3>
              using tf::<wbr /><a href="#a66b72776c788898aee9e132b0ea9b405" class="m-doc-self">DefaultPartitioner</a> = <a href="classtf_1_1GuidedPartitioner.html" class="m-doc">GuidedPartitioner</a>&lt;&gt;
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="partitioner_8hpp.html">&lt;taskflow/algorithm/partitioner.hpp&gt;</a></div>
            </h3>
            <p>default partitioner set to <a href="classtf_1_1GuidedPartitioner.html" class="m-doc">tf::<wbr />GuidedPartitioner</a></p>
<p>Guided partitioning algorithm can achieve stable and decent performance for most parallel algorithms.</p>
          </div></section>
          <section class="m-doc-details" id="a19f35245e6334fae46dccb73f27417bf"><div>
            <h3>
              using tf::<wbr /><a href="#a19f35245e6334fae46dccb73f27417bf" class="m-doc-self">cudaEvent</a> = <a href="classtf_1_1cudaEventBase.html" class="m-doc">cudaEventBase</a>&lt;<a href="structtf_1_1cudaEventCreator.html" class="m-doc">cudaEventCreator</a>, <a href="structtf_1_1cudaEventDeleter.html" class="m-doc">cudaEventDeleter</a>&gt;
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__stream_8hpp.html">&lt;taskflow/cuda/cuda_stream.hpp&gt;</a></div>
            </h3>
            <p>default smart pointer type to manage a <code>cudaEvent_t</code> object with unique ownership</p>
          </div></section>
          <section class="m-doc-details" id="a45b31698cd7ee9a4dcd55465d1e8942a"><div>
            <h3>
              using tf::<wbr /><a href="#a45b31698cd7ee9a4dcd55465d1e8942a" class="m-doc-self">cudaStream</a> = <a href="classtf_1_1cudaStreamBase.html" class="m-doc">cudaStreamBase</a>&lt;<a href="structtf_1_1cudaStreamCreator.html" class="m-doc">cudaStreamCreator</a>, <a href="structtf_1_1cudaStreamDeleter.html" class="m-doc">cudaStreamDeleter</a>&gt;
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__stream_8hpp.html">&lt;taskflow/cuda/cuda_stream.hpp&gt;</a></div>
            </h3>
            <p>default smart pointer type to manage a <code>cudaStream_t</code> object with unique ownership</p>
          </div></section>
          <section class="m-doc-details" id="ac76b07f7b7055967f6a2f1dc78b0978a"><div>
            <h3>
              using tf::<wbr /><a href="#ac76b07f7b7055967f6a2f1dc78b0978a" class="m-doc-self">cudaGraph</a> = <a href="classtf_1_1cudaGraphBase.html" class="m-doc">cudaGraphBase</a>&lt;<a href="structtf_1_1cudaGraphCreator.html" class="m-doc">cudaGraphCreator</a>, <a href="structtf_1_1cudaGraphDeleter.html" class="m-doc">cudaGraphDeleter</a>&gt;
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cudaflow_8hpp.html">&lt;taskflow/cuda/cudaflow.hpp&gt;</a></div>
            </h3>
            <p>default smart pointer type to manage a <code>cudaGraph_t</code> object with unique ownership</p>
          </div></section>
          <section class="m-doc-details" id="a21efbebd2a9b305f43dde90b7b837dc7"><div>
            <h3>
              using tf::<wbr /><a href="#a21efbebd2a9b305f43dde90b7b837dc7" class="m-doc-self">cudaGraphExec</a> = <a href="classtf_1_1cudaGraphExecBase.html" class="m-doc">cudaGraphExecBase</a>&lt;<a href="structtf_1_1cudaGraphExecCreator.html" class="m-doc">cudaGraphExecCreator</a>, <a href="structtf_1_1cudaGraphExecDeleter.html" class="m-doc">cudaGraphExecDeleter</a>&gt;
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cudaflow_8hpp.html">&lt;taskflow/cuda/cudaflow.hpp&gt;</a></div>
            </h3>
            <p>default smart pointer type to manage a <code>cudaGraphExec_t</code> object with unique ownership</p>
          </div></section>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-doc-details" id="ae9682c3db0662fdf6d688a8b095c19ea"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T, std::enable_if_t&lt;(std::is_unsigned_v&lt;std::decay_t&lt;T&gt;&gt; &amp;&amp; sizeof(T)==8), void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">T tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ae9682c3db0662fdf6d688a8b095c19ea" class="m-doc-self">next_pow2</a>(</span><span class="m-doc-wrap">T x) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <p>rounds the given 64-bit unsigned integer to the nearest power of 2</p>
<p>rounds the given 32-bit unsigned integer to the nearest power of 2</p>
          </div></section>
          <section class="m-doc-details" id="a8d48a5014f34a9f97aae5269c2367e38"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;std::decay_t&lt;T&gt;&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">bool tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a8d48a5014f34a9f97aae5269c2367e38" class="m-doc-self">is_pow2</a>(</span><span class="m-doc-wrap">const T&amp; x) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <p>checks if the given number is a power of 2</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>The type of the input. Must be an integral type.</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>x</td>
                  <td>The integer to check.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td><code>true</code> if <code>x</code> is a power of 2, otherwise <code>false</code>.</td>
                </tr>
              </tfoot>
            </table>
<p>This function determines if the given integer is a power of 2.</p><aside class="m-note m-warning"><h4>Attention</h4><p>This function is constexpr and can be evaluated at compile time.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a8845f13b039ef9820087c9f467f6c734"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a8845f13b039ef9820087c9f467f6c734" class="m-doc-self">floor_log2</a>(</span><span class="m-doc-wrap">T n) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <p>computes the floor of the base-2 logarithm of a number using count-leading-zeros (CTL).</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>integer type (uint32_t or uint64_t).</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>n</td>
                  <td>input number.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>floor of <code>log2(n)</code></td>
                </tr>
              </tfoot>
            </table>
<p>This function efficiently calculates the floor of <code>log2(n)</code> for both 32-bit and 64-bit integers.</p>
          </div></section>
          <section class="m-doc-details" id="a0b2dc0c0c931b9b627fc0a148085fa5e"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename RandItr, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper">RandItr tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a0b2dc0c0c931b9b627fc0a148085fa5e" class="m-doc-self">median_of_three</a>(</span><span class="m-doc-wrap">RandItr l,
              RandItr m,
              RandItr r,
              C cmp)</span></span>
            </h3>
            <p>finds the median of three numbers pointed to by iterators using the given comparator</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">RandItr</td>
                  <td>The type of the random-access iterator.</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>The type of the comparator.</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>l</td>
                  <td>Iterator to the first element.</td>
                </tr>
                <tr>
                  <td>m</td>
                  <td>Iterator to the second element.</td>
                </tr>
                <tr>
                  <td>r</td>
                  <td>Iterator to the third element.</td>
                </tr>
                <tr>
                  <td>cmp</td>
                  <td>The comparator used to compare the dereferenced iterator values.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>The iterator pointing to the median value among the three elements.</td>
                </tr>
              </tfoot>
            </table>
<p>This function determines the median value of the elements pointed to by three random-access iterators using the provided comparator.</p>
          </div></section>
          <section class="m-doc-details" id="a5f9a989c8de663d3ee010cbc6de13c91"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename RandItr, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper">RandItr tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a5f9a989c8de663d3ee010cbc6de13c91" class="m-doc-self">pseudo_median_of_nine</a>(</span><span class="m-doc-wrap">RandItr beg,
              RandItr end,
              C cmp)</span></span>
            </h3>
            <p>finds the pseudo median of a range of items using a spread of nine numbers</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">RandItr</td>
                  <td>The type of the random-access iterator.</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>The type of the comparator.</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>beg</td>
                  <td>Iterator to the beginning of the range.</td>
                </tr>
                <tr>
                  <td>end</td>
                  <td>Iterator to the end of the range.</td>
                </tr>
                <tr>
                  <td>cmp</td>
                  <td>The comparator used to compare the dereferenced iterator values.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>The iterator pointing to the pseudo median of the range.</td>
                </tr>
              </tfoot>
            </table>
<p>This function computes an approximate median of a range of items by sampling nine values spread across the range and finding their median. It uses a combination of the <code>median_of_three</code> function to determine the pseudo median.</p><aside class="m-note m-warning"><h4>Attention</h4><p>The pseudo median is an approximation of the true median and may not be the exact middle value of the range.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a8d3fa9252b0da87bff1df912d0a591fe"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename Iter, typename Compare&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a8d3fa9252b0da87bff1df912d0a591fe" class="m-doc-self">sort2</a>(</span><span class="m-doc-wrap">Iter a,
              Iter b,
              Compare comp)</span></span>
            </h3>
            <p>sorts two elements of dereferenced iterators using the given comparison function</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Iter</td>
                  <td>The type of the iterator.</td>
                </tr>
                <tr>
                  <td>Compare</td>
                  <td>The type of the comparator.</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>a</td>
                  <td>Iterator to the first element.</td>
                </tr>
                <tr>
                  <td>b</td>
                  <td>Iterator to the second element.</td>
                </tr>
                <tr>
                  <td>comp</td>
                  <td>The comparator used to compare the dereferenced iterator values.</td>
                </tr>
              </tbody>
            </table>
<p>This function compares two elements pointed to by iterators and swaps them if they are out of order according to the provided comparator.</p>
          </div></section>
          <section class="m-doc-details" id="a86489af717270b8c9b657b347215ef0f"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename Iter, typename Compare&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a86489af717270b8c9b657b347215ef0f" class="m-doc-self">sort3</a>(</span><span class="m-doc-wrap">Iter a,
              Iter b,
              Iter c,
              Compare comp)</span></span>
            </h3>
            <p>Sorts three elements of dereferenced iterators using the given comparison function.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Iter</td>
                  <td>The type of the iterator.</td>
                </tr>
                <tr>
                  <td>Compare</td>
                  <td>The type of the comparator.</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>a</td>
                  <td>Iterator to the first element.</td>
                </tr>
                <tr>
                  <td>b</td>
                  <td>Iterator to the second element.</td>
                </tr>
                <tr>
                  <td>c</td>
                  <td>Iterator to the third element.</td>
                </tr>
                <tr>
                  <td>comp</td>
                  <td>The comparator used to compare the dereferenced iterator values.</td>
                </tr>
              </tbody>
            </table>
<p>This function sorts three elements pointed to by iterators in ascending order according to the provided comparator. The sorting is performed using a sequence of calls to the <code>sort2</code> function to ensure the correct order of elements.</p>
          </div></section>
          <section class="m-doc-details" id="a00b75b92482d883f06282d5181e6f6f9"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">T tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a00b75b92482d883f06282d5181e6f6f9" class="m-doc-self">unique_id</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>generates a program-wide unique ID of the given type in a thread-safe manner</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>The type of the ID to generate. Must be an integral type.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>A unique ID of type <code>T</code>.</td>
                </tr>
              </tfoot>
            </table>
<p>This function provides a globally unique identifier of the specified integral type. It uses a static <code><a href="http://en.cppreference.com/w/cpp/atomic/atomic.html" class="m-doc-external">std::<wbr />atomic</a></code> counter to ensure thread safety and increments the counter in a relaxed memory ordering for efficiency.</p><aside class="m-note m-warning"><h4>Attention</h4><p>The uniqueness of the ID is guaranteed only within the program&#x27;s lifetime.</p><p>The function does not throw exceptions.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a5002af34dc323ff28e87ae83203b2c36"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a5002af34dc323ff28e87ae83203b2c36" class="m-doc-self">atomic_max</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/atomic/atomic.html" class="m-doc-external">std::<wbr />atomic</a>&lt;T&gt;&amp; v,
              const T&amp; max_v) <span class="m-label m-success">noexcept</span></span></span>
            </h3>
            <p>updates an atomic variable with the maximum value</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>The type of the atomic variable. Must be trivially copyable and comparable.</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>v</td>
                  <td>The atomic variable to update.</td>
                </tr>
                <tr>
                  <td>max_v</td>
                  <td>The value to compare with the current value of <code>v</code>.</td>
                </tr>
              </tbody>
            </table>
<p>This function atomically updates the provided atomic variable <code>v</code> to hold the maximum of its current value and <code>max_v</code>. The update is performed using a relaxed memory ordering for efficiency in non-synchronizing contexts.</p><aside class="m-note m-warning"><h4>Attention</h4><p>If multiple threads call this function concurrently, the value of <code>v</code> will be the maximum value seen across all threads.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a512ffa0d24a237b098f5de656b8bdcb0"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a512ffa0d24a237b098f5de656b8bdcb0" class="m-doc-self">atomic_min</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/atomic/atomic.html" class="m-doc-external">std::<wbr />atomic</a>&lt;T&gt;&amp; v,
              const T&amp; min_v) <span class="m-label m-success">noexcept</span></span></span>
            </h3>
            <p>updates an atomic variable with the minimum value</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>The type of the atomic variable. Must be trivially copyable and comparable.</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>v</td>
                  <td>The atomic variable to update.</td>
                </tr>
                <tr>
                  <td>min_v</td>
                  <td>The value to compare with the current value of <code>v</code>.</td>
                </tr>
              </tbody>
            </table>
<p>This function atomically updates the provided atomic variable <code>v</code> to hold the minimum of its current value and <code>min_v</code>. The update is performed using a relaxed memory ordering for efficiency in non-synchronizing contexts.</p><aside class="m-note m-warning"><h4>Attention</h4><p>If multiple threads call this function concurrently, the value of <code>v</code> will be the minimum value seen across all threads.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a3f8e89aebc29d42259157723c874954d"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper">T tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a3f8e89aebc29d42259157723c874954d" class="m-doc-self">seed</a>(</span><span class="m-doc-wrap">) <span class="m-label m-success">noexcept</span></span></span>
            </h3>
            <p>generates a random seed based on the current system clock</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>The type of the returned seed. Must be an integral type.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>A seed value based on the system clock.</td>
                </tr>
              </tfoot>
            </table>
<p>This function returns a seed value derived from the number of clock ticks since the epoch as measured by the system clock. The seed can be used to initialize random number generators.</p>
          </div></section>
          <section class="m-doc-details" id="a0b8e46604b2d40f0a7f2cc4796003d49"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T, typename = std::enable_if_t&lt;std::is_unsigned_v&lt;T&gt;&gt;&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a0b8e46604b2d40f0a7f2cc4796003d49" class="m-doc-self">ctz</a>(</span><span class="m-doc-wrap">T x)</span></span>
            </h3>
            <p>counts the number of trailing zeros in an integer.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>integer type (32-bit or 64-bit).</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>x</td>
                  <td>non-zero integer to count trailing zeros from</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>the number of trailing zeros in <code>x</code></td>
                </tr>
              </tfoot>
            </table>
<p>This function provides a portable implementation for counting the number of trailing zeros across different platforms and integer sizes (32-bit and 64-bit).</p><aside class="m-note m-warning"><h4>Attention</h4><p>The behavior is undefined when <code>x</code> is 0.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a15c9131faea47635a65e6caf21b6f868"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a15c9131faea47635a65e6caf21b6f868" class="m-doc-self">coprime</a>(</span><span class="m-doc-wrap">size_t N) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <p>computes a coprime of a given number</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">N</td>
                  <td>input number for which a coprime is to be found.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>the largest number &lt; <code>N</code> that is coprime to N</td>
                </tr>
              </tfoot>
            </table>
<p>This function finds the largest number less than N that is coprime (i.e., has a greatest common divisor of 1) with <code>N</code>. If <code>N</code> is less than 3, it returns 1 as a default coprime.</p>
          </div></section>
          <section class="m-doc-details" id="af96bfc2b11d1743ca2d344e08a484d5e"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;size_t N&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="http://en.cppreference.com/w/cpp/container/array.html" class="m-doc-external">std::<wbr />array</a>&lt;size_t, N&gt; tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#af96bfc2b11d1743ca2d344e08a484d5e" class="m-doc-self">make_coprime_lut</a>(</span><span class="m-doc-wrap">) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <p>generates a compile-time array of coprimes for numbers from 0 to N-1</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">N</td>
                  <td>the size of the array to generate (should be greater than 0).</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a constexpr array of size <code>N</code> where each index holds a coprime of its value.</td>
                </tr>
              </tfoot>
            </table>
<p>This function constructs a constexpr array where each element at index <code>i</code> contains a coprime of <code>i</code> (the largest number less than <code>i</code> that is coprime to it).</p>
          </div></section>
          <section class="m-doc-details" id="abbef08f01c467fd4f746c3247af892bc"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html" class="m-doc-external">std::<wbr />string</a> tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#abbef08f01c467fd4f746c3247af892bc" class="m-doc-self">get_env</a>(</span><span class="m-doc-wrap">const <a href="http://en.cppreference.com/w/cpp/string/basic_string.html" class="m-doc-external">std::<wbr />string</a>&amp; str)</span></span>
            </h3>
            <p>retrieves the value of an environment variable</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">str</td>
                  <td>The name of the environment variable to retrieve.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>The value of the environment variable as a string, or an empty string if not found.</td>
                </tr>
              </tfoot>
            </table>
<p>This function fetches the value of an environment variable by name. If the variable is not found, it returns an empty string.</p><aside class="m-note m-warning"><h4>Attention</h4><p>The implementation differs between Windows and POSIX platforms:</p><ul><li>On Windows, it uses <code>_dupenv_s</code> to fetch the value.</li><li>On POSIX, it uses <code>std::getenv</code>.</li></ul></aside>
          </div></section>
          <section class="m-doc-details" id="adc9815b9f96b796675ba939078d25413"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#adc9815b9f96b796675ba939078d25413" class="m-doc-self">has_env</a>(</span><span class="m-doc-wrap">const <a href="http://en.cppreference.com/w/cpp/string/basic_string.html" class="m-doc-external">std::<wbr />string</a>&amp; str)</span></span>
            </h3>
            <p>checks whether an environment variable is defined</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">str</td>
                  <td>The name of the environment variable to check.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td><code>true</code> if the environment variable exists, <code>false</code> otherwise.</td>
                </tr>
              </tfoot>
            </table>
<p>This function determines if a specific environment variable exists in the current environment.</p><aside class="m-note m-warning"><h4>Attention</h4><p>The implementation differs between Windows and POSIX platforms:</p><ul><li>On Windows, it uses <code>_dupenv_s</code> to check for the variable&#x27;s presence.</li><li>On POSIX, it uses <code>std::getenv</code> to check for the variable&#x27;s presence.</li></ul></aside>
          </div></section>
          <section class="m-doc-details" id="aef9af2433294beb7d41680e5b33eafdd"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aef9af2433294beb7d41680e5b33eafdd" class="m-doc-self">pause</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
<p>This function is used in spin-wait loops to hint the CPU that the current thread is in a busy-wait state. It helps reduce power consumption and improves performance on hyper-threaded processors by preventing the CPU from consuming unnecessary cycles while waiting. It is particularly useful in low-contention scenarios, where the thread is likely to quickly acquire the lock or condition it&#x27;s waiting for, avoiding an expensive context switch. On modern x86 processors, this instruction can be invoked using <code>__builtin_ia32_pause()</code> in GCC/Clang or <code>_mm_pause()</code> in MSVC. In non-x86 architectures, alternative mechanisms such as yielding the CPU may be used instead.</p>
          </div></section>
          <section class="m-doc-details" id="a3abe09ef55c4f46e64ba88bff175c4f6"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a3abe09ef55c4f46e64ba88bff175c4f6" class="m-doc-self">spin_until</a>(</span><span class="m-doc-wrap">P&amp;&amp; predicate)</span></span>
            </h3>
            <p>spins until the given predicate becomes true</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">P</td>
                  <td>the type of the predicate function or callable.</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>predicate</td>
                  <td>the callable that returns a boolean value, which is checked in the loop.</td>
                </tr>
              </tbody>
            </table>
<p>This function repeatedly checks the provided predicate in a spin-wait loop and uses a backoff strategy to minimize CPU waste during the wait. Initially, it uses the <code><a href="#aef9af2433294beb7d41680e5b33eafdd" class="m-doc">pause()</a></code> instruction for the first 100 iterations to hint to the CPU that the thread is waiting, thus reducing power consumption and avoiding unnecessary cycles. After 100 iterations, it switches to yielding the CPU using <code><a href="http://en.cppreference.com/w/cpp/thread/yield.html" class="m-doc-external">std::<wbr />this_thread::<wbr />yield()</a></code> to allow other threads to run and improve system responsiveness.</p><p>The function operates as follows:</p><ol><li>For the first 100 iterations, it invokes <code><a href="#aef9af2433294beb7d41680e5b33eafdd" class="m-doc">pause()</a></code> to reduce power consumption during the spin-wait.</li><li>After 100 iterations, it uses <code><a href="http://en.cppreference.com/w/cpp/thread/yield.html" class="m-doc-external">std::<wbr />this_thread::<wbr />yield()</a></code> to relinquish the CPU, allowing other threads to execute.</li></ol><aside class="m-note m-warning"><h4>Attention</h4><p>This function is useful when you need to wait for a condition to be true, but want to optimize CPU usage during the wait by using a busy-wait approach.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a5643bf94c64370ee721692e3e6d9dc80"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename S&gt;
              </div>
              <span class="m-doc-wrap-bumper">std::enable_if_t&lt;std::is_integral_v&lt;std::decay_t&lt;B&gt;&gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;E&gt;&gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;S&gt;&gt;, bool&gt; tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a5643bf94c64370ee721692e3e6d9dc80" class="m-doc-self">is_index_range_invalid</a>(</span><span class="m-doc-wrap">B beg,
              E end,
              S step) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <p>checks if the given index range is invalid</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>type of the beginning index</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>type of the ending index</td>
                </tr>
                <tr>
                  <td>S</td>
                  <td>type of the step size</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>beg</td>
                  <td>starting index of the range</td>
                </tr>
                <tr>
                  <td>end</td>
                  <td>ending index of the range</td>
                </tr>
                <tr>
                  <td>step</td>
                  <td>step size to traverse the range</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>returns <code>true</code> if the range is invalid; <code>false</code> otherwise.</td>
                </tr>
              </tfoot>
            </table>
<p>A range is considered invalid under the following conditions:</p><ul><li>The step is zero and the begin and end values are not equal.</li><li>A positive range (begin &lt; end) with a non-positive step.</li><li>A negative range (begin &gt; end) with a non-negative step.</li></ul>
          </div></section>
          <section class="m-doc-details" id="a02a73acf6a05a3a4c673068daaad866f"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename S&gt;
              </div>
              <span class="m-doc-wrap-bumper">std::enable_if_t&lt;std::is_integral_v&lt;std::decay_t&lt;B&gt;&gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;E&gt;&gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;S&gt;&gt;, size_t&gt; tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a02a73acf6a05a3a4c673068daaad866f" class="m-doc-self">distance</a>(</span><span class="m-doc-wrap">B beg,
              E end,
              S step) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <p>calculates the number of iterations in the given index range</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>type of the beginning index</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>type of the ending index</td>
                </tr>
                <tr>
                  <td>S</td>
                  <td>type of the step size</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>beg</td>
                  <td>starting index of the range</td>
                </tr>
                <tr>
                  <td>end</td>
                  <td>ending index of the range</td>
                </tr>
                <tr>
                  <td>step</td>
                  <td>step size to traverse the range</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>returns the number of required iterations to traverse the range</td>
                </tr>
              </tfoot>
            </table>
<p>The distance of a range represents the number of required iterations to traverse the range from the beginning index to the ending index (exclusive) with the given step size.</p><p>Example 1:</p><pre class="m-code"><span class="c1">// Range: 0 to 10 with step size 2</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">  </span><span class="c1">// Returns 5, the sequence is [0, 2, 4, 6, 8]</span></pre><p>Example 2:</p><pre class="m-code"><span class="c1">// Range: 10 to 0 with step size -2</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distance</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-2</span><span class="p">);</span><span class="w">  </span><span class="c1">// Returns 5, the sequence is [10, 8, 6, 4, 2]</span></pre><p>Example 3:</p><pre class="m-code"><span class="c1">// Range: 5 to 20 with step size 5</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distance</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w">  </span><span class="c1">// Returns 3, the sequence is [5, 10, 15]</span></pre><aside class="m-note m-warning"><h4>Attention</h4><p>It is user&#x27;s responsibility to ensure the given index range is valid.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a97960776f3c78e18e68c79c336ba4f2d"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="worker_8hpp.html">&lt;taskflow/core/worker.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename T, typename... ArgsT&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html" class="m-doc-external">std::<wbr />unique_ptr</a>&lt;T&gt; tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a97960776f3c78e18e68c79c336ba4f2d" class="m-doc-self">make_worker_interface</a>(</span><span class="m-doc-wrap">ArgsT &amp;&amp; ... args)</span></span>
            </h3>
            <p>helper function to create an instance derived from <a href="classtf_1_1WorkerInterface.html" class="m-doc">tf::<wbr />WorkerInterface</a></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>type derived from <a href="classtf_1_1WorkerInterface.html" class="m-doc">tf::<wbr />WorkerInterface</a></td>
                </tr>
                <tr>
                  <td>ArgsT</td>
                  <td>argument types to construct <code>T</code></td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>args</td>
                  <td>arguments to forward to the constructor of <code>T</code></td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-doc-details" id="a9ca58dc6c666698cc7373eb0262140ef"><div>
            <h3>
              <span class="m-doc-wrap-bumper">const char* tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a9ca58dc6c666698cc7373eb0262140ef" class="m-doc-self">to_string</a>(</span><span class="m-doc-wrap"><a href="#a1355048578785a80414707ff308b395a" class="m-doc">TaskType</a> type)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="task_8hpp.html">&lt;taskflow/core/task.hpp&gt;</a></div>
            </h3>
            <p>convert a task type to a human-readable string</p>
<p>The name of each task type is the litte-case string of its characters.</p><pre class="m-code"><span class="n">TaskType</span><span class="o">::</span><span class="n">PLACEHOLDER</span><span class="w">     </span><span class="o">-&gt;</span><span class="w">  </span><span class="s">&quot;placeholder&quot;</span>
<span class="n">TaskType</span><span class="o">::</span><span class="n">STATIC</span><span class="w">          </span><span class="o">-&gt;</span><span class="w">  </span><span class="s">&quot;static&quot;</span>
<span class="n">TaskType</span><span class="o">::</span><span class="n">RUNTIME</span><span class="w">         </span><span class="o">-&gt;</span><span class="w">  </span><span class="s">&quot;runtime&quot;</span>
<span class="n">TaskType</span><span class="o">::</span><span class="n">SUBFLOW</span><span class="w">         </span><span class="o">-&gt;</span><span class="w">  </span><span class="s">&quot;subflow&quot;</span>
<span class="n">TaskType</span><span class="o">::</span><span class="n">CONDITION</span><span class="w">       </span><span class="o">-&gt;</span><span class="w">  </span><span class="s">&quot;condition&quot;</span>
<span class="n">TaskType</span><span class="o">::</span><span class="n">MODULE</span><span class="w">          </span><span class="o">-&gt;</span><span class="w">  </span><span class="s">&quot;module&quot;</span>
<span class="n">TaskType</span><span class="o">::</span><span class="n">ASYNC</span><span class="w">           </span><span class="o">-&gt;</span><span class="w">  </span><span class="s">&quot;async&quot;</span></pre>
          </div></section>
          <section class="m-doc-details" id="ad216aea4d0f648e149e47374ad015b1f"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html" class="m-doc-external">std::<wbr />ostream</a>&amp; tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ad216aea4d0f648e149e47374ad015b1f" class="m-doc-self">operator&lt;&lt;</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html" class="m-doc-external">std::<wbr />ostream</a>&amp; os,
              const <a href="classtf_1_1Task.html" class="m-doc">Task</a>&amp; task)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="task_8hpp.html">&lt;taskflow/core/task.hpp&gt;</a></div>
            </h3>
            <p>overload of ostream inserter operator for <a href="classtf_1_1Task.html" class="m-doc">Task</a></p>
          </div></section>
          <section class="m-doc-details" id="aa3fc0699b2c2b8f2f76bb39f91be1acb"><div>
            <h3>
              <span class="m-doc-wrap-bumper">const char* tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aa3fc0699b2c2b8f2f76bb39f91be1acb" class="m-doc-self">to_string</a>(</span><span class="m-doc-wrap"><a href="#a192f7cb0fab2eb6f1c84f6046706435d" class="m-doc">ObserverType</a> type)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="observer_8hpp.html">&lt;taskflow/core/observer.hpp&gt;</a></div>
            </h3>
            <p>convert an observer type to a human-readable string</p>
          </div></section>
          <section class="m-doc-details" id="a8975fa5762088789adb0b60f38208309"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename Input, typename Output, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a8975fa5762088789adb0b60f38208309" class="m-doc-self">make_data_pipe</a>(</span><span class="m-doc-wrap"><a href="#abb7a11e41fd457f69e7ff45d4c769564" class="m-doc">PipeType</a> d,
              C&amp;&amp; callable)</span></span>
            </h3>
            <p>function to construct a data pipe (<a href="classtf_1_1DataPipe.html" class="m-doc">tf::<wbr />DataPipe</a>)</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Input</td>
                  <td>input data type</td>
                </tr>
                <tr>
                  <td>Output</td>
                  <td>output data type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
              </tbody>
            </table>
<p><a href="#a8975fa5762088789adb0b60f38208309" class="m-doc">tf::<wbr />make_data_pipe</a> is a helper function to create a data pipe (<a href="classtf_1_1DataPipe.html" class="m-doc">tf::<wbr />DataPipe</a>) in a data-parallel pipeline (<a href="classtf_1_1DataPipeline.html" class="m-doc">tf::<wbr />DataPipeline</a>). The first argument specifies the direction of the data pipe, either <a href="#abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" class="m-doc">tf::<wbr />PipeType::<wbr />SERIAL</a> or <a href="#abb7a11e41fd457f69e7ff45d4c769564adf13a99b035d6f0bce4f44ab18eec8eb" class="m-doc">tf::<wbr />PipeType::<wbr />PARALLEL</a>, and the second argument is a callable to invoke by the pipeline scheduler. Input and output data types are specified via template parameters, which will always be decayed by the library to its original form for storage purpose. The callable must take the input data type in its first argument and returns a value of the output data type.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">make_data_pipe</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">PipeType</span><span class="o">::</span><span class="n">SERIAL</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="p">[](</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">);</span></pre><p>The callable can additionally take a reference of <a href="classtf_1_1Pipeflow.html" class="m-doc">tf::<wbr />Pipeflow</a>, which allows you to query the runtime information of a stage task, such as its line number and token number.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">make_data_pipe</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">PipeType</span><span class="o">::</span><span class="n">SERIAL</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="p">[](</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">tf</span><span class="o">::</span><span class="n">Pipeflow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;token=%lu, line=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pf</span><span class="p">.</span><span class="n">token</span><span class="p">(),</span><span class="w"> </span><span class="n">pf</span><span class="p">.</span><span class="n">line</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">input</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">);</span></pre>
          </div></section>
          <section class="m-doc-details" id="aae281ad3b89a5c421a1f4058f425e54c"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aae281ad3b89a5c421a1f4058f425e54c" class="m-doc-self">make_module_task</a>(</span><span class="m-doc-wrap">T&amp;&amp; target)</span></span>
            </h3>
            <p>creates a module task using the given target</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>Type of the target object, which must define the method <code><a href="classtf_1_1Graph.html" class="m-doc">tf::<wbr />Graph</a>&amp; graph()</code>.</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>target</td>
                  <td>The target object used to create the module task.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>module task that can be used by Taskflow or asynchronous tasking.</td>
                </tr>
              </tfoot>
            </table>
<p>This example demonstrates how to create and launch multiple taskflows in parallel using asynchronous tasking:</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Executor</span><span class="w"> </span><span class="n">executor</span><span class="p">;</span>

<span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">C</span><span class="p">;</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">D</span><span class="p">;</span>

<span class="n">A</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Taskflow A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"> </span>
<span class="n">B</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Taskflow B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"> </span>
<span class="n">C</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Taskflow C</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"> </span>
<span class="n">D</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Taskflow D</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"> </span>

<span class="c1">// launch the four taskflows using asynchronous tasking</span>
<span class="n">executor</span><span class="p">.</span><span class="n">async</span><span class="p">(</span><span class="n">tf</span><span class="o">::</span><span class="n">make_module_task</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>
<span class="n">executor</span><span class="p">.</span><span class="n">async</span><span class="p">(</span><span class="n">tf</span><span class="o">::</span><span class="n">make_module_task</span><span class="p">(</span><span class="n">B</span><span class="p">));</span>
<span class="n">executor</span><span class="p">.</span><span class="n">async</span><span class="p">(</span><span class="n">tf</span><span class="o">::</span><span class="n">make_module_task</span><span class="p">(</span><span class="n">C</span><span class="p">));</span>
<span class="n">executor</span><span class="p">.</span><span class="n">async</span><span class="p">(</span><span class="n">tf</span><span class="o">::</span><span class="n">make_module_task</span><span class="p">(</span><span class="n">D</span><span class="p">));</span>
<span class="n">executor</span><span class="p">.</span><span class="n">wait_for_all</span><span class="p">();</span><span class="w">  </span></pre><p>The module task maker, <a href="#aae281ad3b89a5c421a1f4058f425e54c" class="m-doc">tf::<wbr />make_module_task</a>, is basically the same as <a href="classtf_1_1FlowBuilder.html#ac6f22228d4c2ea2e643c4b0d42c0e92a" class="m-doc">tf::<wbr />Taskflow::<wbr />composed_of</a> but provides a more generic interface that can be used beyond Taskflow. For instance, the following two approaches achieve the same functionality.</p><pre class="m-code"><span class="c1">// approach 1: composition using composed_of</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow1</span><span class="p">.</span><span class="n">composed_of</span><span class="p">(</span><span class="n">taskflow2</span><span class="p">);</span>

<span class="c1">// approach 2: composition using make_module_task</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow1</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">tf</span><span class="o">::</span><span class="n">make_module_task</span><span class="p">(</span><span class="n">taskflow2</span><span class="p">));</span></pre><aside class="m-note m-warning"><h4>Attention</h4><p>Users are responsible for ensuring that the given target remains valid throughout its execution. The executor does not assume ownership of the target object.</p></aside>
          </div></section>
          <section class="m-doc-details" id="abffa70155a5f160b7ceb86ee52ab2136"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#abffa70155a5f160b7ceb86ee52ab2136" class="m-doc-self">cuda_get_num_devices</a>(</span><span class="m-doc-wrap">)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the number of available devices</p>
          </div></section>
          <section class="m-doc-details" id="a235f5a9ce203d538eec1f4114221d473"><div>
            <h3>
              <span class="m-doc-wrap-bumper">int tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a235f5a9ce203d538eec1f4114221d473" class="m-doc-self">cuda_get_device</a>(</span><span class="m-doc-wrap">)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>gets the current device associated with the caller thread</p>
          </div></section>
          <section class="m-doc-details" id="ade2938289fa49aafc9b2b7b090deaa22"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ade2938289fa49aafc9b2b7b090deaa22" class="m-doc-self">cuda_set_device</a>(</span><span class="m-doc-wrap">int id)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>switches to a given device context</p>
          </div></section>
          <section class="m-doc-details" id="a403b679694f4c85c857163b47e84d566"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a403b679694f4c85c857163b47e84d566" class="m-doc-self">cuda_get_device_property</a>(</span><span class="m-doc-wrap">int i,
              cudaDeviceProp&amp; p)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>obtains the device property</p>
          </div></section>
          <section class="m-doc-details" id="a0e82b8a929e12349240276e34ec9f8c8"><div>
            <h3>
              <span class="m-doc-wrap-bumper">cudaDeviceProp tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a0e82b8a929e12349240276e34ec9f8c8" class="m-doc-self">cuda_get_device_property</a>(</span><span class="m-doc-wrap">int i)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>obtains the device property</p>
          </div></section>
          <section class="m-doc-details" id="aff8073c78daa741df76b530a0e602287"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aff8073c78daa741df76b530a0e602287" class="m-doc-self">cuda_dump_device_property</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html" class="m-doc-external">std::<wbr />ostream</a>&amp; os,
              const cudaDeviceProp&amp; p)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>dumps the device property</p>
          </div></section>
          <section class="m-doc-details" id="abf813f7ac4249d1b752d1b724f970deb"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#abf813f7ac4249d1b752d1b724f970deb" class="m-doc-self">cuda_get_device_max_threads_per_block</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the maximum threads per block on a device</p>
          </div></section>
          <section class="m-doc-details" id="af8184bb128c446fe383315f3dc15acf6"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#af8184bb128c446fe383315f3dc15acf6" class="m-doc-self">cuda_get_device_max_x_dim_per_block</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the maximum x-dimension per block on a device</p>
          </div></section>
          <section class="m-doc-details" id="a9aba5f29135b9da29015c2a367ab1d70"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a9aba5f29135b9da29015c2a367ab1d70" class="m-doc-self">cuda_get_device_max_y_dim_per_block</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the maximum y-dimension per block on a device</p>
          </div></section>
          <section class="m-doc-details" id="a5580f59e633625b2f344bbf477d17c2f"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a5580f59e633625b2f344bbf477d17c2f" class="m-doc-self">cuda_get_device_max_z_dim_per_block</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the maximum z-dimension per block on a device</p>
          </div></section>
          <section class="m-doc-details" id="a597579c8a9ab31244418e30a5aa74491"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a597579c8a9ab31244418e30a5aa74491" class="m-doc-self">cuda_get_device_max_x_dim_per_grid</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the maximum x-dimension per grid on a device</p>
          </div></section>
          <section class="m-doc-details" id="a91d5c1609a7542949dd56d08b7c4c645"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a91d5c1609a7542949dd56d08b7c4c645" class="m-doc-self">cuda_get_device_max_y_dim_per_grid</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the maximum y-dimension per grid on a device</p>
          </div></section>
          <section class="m-doc-details" id="a0373e32a20c7fc90c4f0461ee41bb918"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a0373e32a20c7fc90c4f0461ee41bb918" class="m-doc-self">cuda_get_device_max_z_dim_per_grid</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the maximum z-dimension per grid on a device</p>
          </div></section>
          <section class="m-doc-details" id="aeca46ac171c4941a75aafddfe7546bfa"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aeca46ac171c4941a75aafddfe7546bfa" class="m-doc-self">cuda_get_device_max_shm_per_block</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the maximum shared memory size in bytes per block on a device</p>
          </div></section>
          <section class="m-doc-details" id="aea1b2af1073496f047d6fb9984cff4f1"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aea1b2af1073496f047d6fb9984cff4f1" class="m-doc-self">cuda_get_device_warp_size</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the warp size on a device</p>
          </div></section>
          <section class="m-doc-details" id="a1fb03793a6b8705026b80ef87599d4d5"><div>
            <h3>
              <span class="m-doc-wrap-bumper">int tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a1fb03793a6b8705026b80ef87599d4d5" class="m-doc-self">cuda_get_device_compute_capability_major</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the major number of compute capability of a device</p>
          </div></section>
          <section class="m-doc-details" id="a71f5177665f4f7e18984ccc57d625602"><div>
            <h3>
              <span class="m-doc-wrap-bumper">int tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a71f5177665f4f7e18984ccc57d625602" class="m-doc-self">cuda_get_device_compute_capability_minor</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the minor number of compute capability of a device</p>
          </div></section>
          <section class="m-doc-details" id="ad389294b4d1c14219d8d098f796e27c5"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ad389294b4d1c14219d8d098f796e27c5" class="m-doc-self">cuda_get_device_unified_addressing</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries if the device supports unified addressing</p>
          </div></section>
          <section class="m-doc-details" id="a43ac57f0eca3aa83c04bec3c4da9ab82"><div>
            <h3>
              <span class="m-doc-wrap-bumper">int tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a43ac57f0eca3aa83c04bec3c4da9ab82" class="m-doc-self">cuda_get_driver_version</a>(</span><span class="m-doc-wrap">)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the latest CUDA version (1000 * major + 10 * minor) supported by the driver</p>
          </div></section>
          <section class="m-doc-details" id="a31258ad089c6f847c8cd636cd72d6949"><div>
            <h3>
              <span class="m-doc-wrap-bumper">int tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a31258ad089c6f847c8cd636cd72d6949" class="m-doc-self">cuda_get_runtime_version</a>(</span><span class="m-doc-wrap">)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__device_8hpp.html">&lt;taskflow/cuda/cuda_device.hpp&gt;</a></div>
            </h3>
            <p>queries the CUDA <a href="classtf_1_1Runtime.html" class="m-doc">Runtime</a> version (1000 * major + 10 * minor)</p>
          </div></section>
          <section class="m-doc-details" id="a1effcf929b7e488925f9e12d74c8c62b"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a1effcf929b7e488925f9e12d74c8c62b" class="m-doc-self">cuda_get_free_mem</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__memory_8hpp.html">&lt;taskflow/cuda/cuda_memory.hpp&gt;</a></div>
            </h3>
            <p>queries the free memory (expensive call)</p>
          </div></section>
          <section class="m-doc-details" id="a58bbc8d5d955582d6b5f7fdac51d010b"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a58bbc8d5d955582d6b5f7fdac51d010b" class="m-doc-self">cuda_get_total_mem</a>(</span><span class="m-doc-wrap">int d)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__memory_8hpp.html">&lt;taskflow/cuda/cuda_memory.hpp&gt;</a></div>
            </h3>
            <p>queries the total available memory (expensive call)</p>
          </div></section>
          <section class="m-doc-details" id="a6f04fd3168c45eeb2dffb223e5c81e45"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__memory_8hpp.html">&lt;taskflow/cuda/cuda_memory.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper">T* tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a6f04fd3168c45eeb2dffb223e5c81e45" class="m-doc-self">cuda_malloc_device</a>(</span><span class="m-doc-wrap">size_t N,
              int d)</span></span>
            </h3>
            <p>allocates memory on the given device for holding <code>N</code> elements of type <code>T</code></p>
<p>The function calls <code>cudaMalloc</code> to allocate <code>N*sizeof(T)</code> bytes of memory on the given device <code>d</code> and returns a pointer to the starting address of the device memory.</p>
          </div></section>
          <section class="m-doc-details" id="ab9b68b8f4336f13b190d573969cb1cf7"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__memory_8hpp.html">&lt;taskflow/cuda/cuda_memory.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper">T* tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ab9b68b8f4336f13b190d573969cb1cf7" class="m-doc-self">cuda_malloc_device</a>(</span><span class="m-doc-wrap">size_t N)</span></span>
            </h3>
            <p>allocates memory on the current device associated with the caller</p>
<p>The function calls malloc_device from the current device associated with the caller.</p>
          </div></section>
          <section class="m-doc-details" id="a8eed05685b030fc44703213a4ef86f11"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__memory_8hpp.html">&lt;taskflow/cuda/cuda_memory.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper">T* tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a8eed05685b030fc44703213a4ef86f11" class="m-doc-self">cuda_malloc_shared</a>(</span><span class="m-doc-wrap">size_t N)</span></span>
            </h3>
            <p>allocates shared memory for holding <code>N</code> elements of type <code>T</code></p>
<p>The function calls <code>cudaMallocManaged</code> to allocate <code>N*sizeof(T)</code> bytes of memory and returns a pointer to the starting address of the shared memory.</p>
          </div></section>
          <section class="m-doc-details" id="ac7a8fe7456b888d6072ba94783c5003c"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__memory_8hpp.html">&lt;taskflow/cuda/cuda_memory.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ac7a8fe7456b888d6072ba94783c5003c" class="m-doc-self">cuda_free</a>(</span><span class="m-doc-wrap">T* ptr,
              int d)</span></span>
            </h3>
            <p>frees memory on the GPU device</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>pointer type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>ptr</td>
                  <td>device pointer to memory to free</td>
                </tr>
                <tr>
                  <td>d</td>
                  <td>device context identifier</td>
                </tr>
              </tbody>
            </table>
<p>This methods call <code>cudaFree</code> to free the memory space pointed to by <code>ptr</code> using the given device context.</p>
          </div></section>
          <section class="m-doc-details" id="ae174a3a49b91ef21554dac16806f0d72"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__memory_8hpp.html">&lt;taskflow/cuda/cuda_memory.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ae174a3a49b91ef21554dac16806f0d72" class="m-doc-self">cuda_free</a>(</span><span class="m-doc-wrap">T* ptr)</span></span>
            </h3>
            <p>frees memory on the GPU device</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>pointer type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>ptr</td>
                  <td>device pointer to memory to free</td>
                </tr>
              </tbody>
            </table>
<p>This methods call <code>cudaFree</code> to free the memory space pointed to by <code>ptr</code> using the current device context of the caller.</p>
          </div></section>
          <section class="m-doc-details" id="aa4266474b921f8ed7d9ec8071fded2a4"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aa4266474b921f8ed7d9ec8071fded2a4" class="m-doc-self">cuda_memcpy_async</a>(</span><span class="m-doc-wrap">cudaStream_t stream,
              void* dst,
              const void* src,
              size_t count)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__memory_8hpp.html">&lt;taskflow/cuda/cuda_memory.hpp&gt;</a></div>
            </h3>
            <p>copies data between host and device asynchronously through a stream</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">stream</td>
                  <td>stream identifier</td>
                </tr>
                <tr>
                  <td>dst</td>
                  <td>destination memory address</td>
                </tr>
                <tr>
                  <td>src</td>
                  <td>source memory address</td>
                </tr>
                <tr>
                  <td>count</td>
                  <td>size in bytes to copy</td>
                </tr>
              </tbody>
            </table>
<p>The method calls <code>cudaMemcpyAsync</code> with the given <code>stream</code> using <code>cudaMemcpyDefault</code> to infer the memory space of the source and the destination pointers. The memory areas may not overlap.</p>
          </div></section>
          <section class="m-doc-details" id="a6615554d2954e895755411ee444d9760"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a6615554d2954e895755411ee444d9760" class="m-doc-self">cuda_memset_async</a>(</span><span class="m-doc-wrap">cudaStream_t stream,
              void* devPtr,
              int value,
              size_t count)</span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="cuda__memory_8hpp.html">&lt;taskflow/cuda/cuda_memory.hpp&gt;</a></div>
            </h3>
            <p>initializes or sets GPU memory to the given value byte by byte</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">stream</td>
                  <td>stream identifier</td>
                </tr>
                <tr>
                  <td>devPtr</td>
                  <td>pointer to GPU memory</td>
                </tr>
                <tr>
                  <td>value</td>
                  <td>value to set for each byte of the specified memory</td>
                </tr>
                <tr>
                  <td>count</td>
                  <td>size in bytes to set</td>
                </tr>
              </tbody>
            </table>
<p>The method calls <code>cudaMemsetAsync</code> with the given <code>stream</code> to fill the first <code>count</code> bytes of the memory area pointed to by <code>devPtr</code> with the constant byte value <code>value</code>.</p>
          </div></section>
          <section class="m-doc-details" id="afb8f9fd1a826738ea95b4cf224c65cb0"><div>
            <h3>
              <span class="m-doc-wrap-bumper">cudaGraphNodeType tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#afb8f9fd1a826738ea95b4cf224c65cb0" class="m-doc-self">cuda_get_graph_node_type</a>(</span><span class="m-doc-wrap">cudaGraphNode_t node)</span></span>
            </h3>
            <p>queries the type of a native CUDA graph node</p>
<p>valid type values are:</p><ul><li>cudaGraphNodeTypeKernel = 0x00</li><li>cudaGraphNodeTypeMemcpy = 0x01</li><li>cudaGraphNodeTypeMemset = 0x02</li><li>cudaGraphNodeTypeHost = 0x03</li><li>cudaGraphNodeTypeGraph = 0x04</li><li>cudaGraphNodeTypeEmpty = 0x05</li><li>cudaGraphNodeTypeWaitEvent = 0x06</li><li>cudaGraphNodeTypeEventRecord = 0x07</li></ul>
          </div></section>
          <section class="m-doc-details" id="a30fa078dcf625e9eada5a95af1467588"><div>
            <h3>
              <span class="m-doc-wrap-bumper">const char* tf::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a30fa078dcf625e9eada5a95af1467588" class="m-doc-self">version</a>(</span><span class="m-doc-wrap">) <span class="m-label m-primary">constexpr</span></span></span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="taskflow_8hpp.html">&lt;taskflow/taskflow.hpp&gt;</a></div>
            </h3>
            <p>queries the version information in a string format <code>major.minor.patch</code></p>
<p>Release notes are available here: <a href="https://taskflow.github.io/taskflow/Releases.html">https:/<wbr />/<wbr />taskflow.github.io/<wbr />taskflow/<wbr />Releases.html</a></p>
          </div></section>
        </section>
        <section>
          <h2>Variable documentation</h2>
          <section class="m-doc-details" id="ad3a41adc2499a9519da3e77dc3e9849c"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="graph_8hpp.html">&lt;taskflow/core/graph.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename P&gt;
              </div>
              bool tf::<wbr /><a href="#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc-self">is_task_params_v</a> <span class="m-label m-primary">constexpr</span>
            </h3>
            <p>determines if the given type is a task parameter type</p>
<p><a href="classtf_1_1Task.html" class="m-doc">Task</a> parameters can be specified in one of the following types:</p><ul><li><a href="structtf_1_1TaskParams.html" class="m-doc">tf::<wbr />TaskParams</a>: assign the struct of defined parameters</li><li><a href="structtf_1_1DefaultTaskParams.html" class="m-doc">tf::<wbr />DefaultTaskParams</a>: assign nothing</li><li><a href="http://en.cppreference.com/w/cpp/string/basic_string.html" class="m-doc-external">std::<wbr />string</a>: assign a name to the task</li></ul>
          </div></section>
          <section class="m-doc-details" id="aea3945d9b15c96a72540ea4fe61947e7"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="graph_8hpp.html">&lt;taskflow/core/graph.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              bool tf::<wbr /><a href="#aea3945d9b15c96a72540ea4fe61947e7" class="m-doc-self">has_graph_v</a> <span class="m-label m-primary">constexpr</span>
            </h3>
            <p>determines if the given type has a member function <code><a href="classtf_1_1Graph.html" class="m-doc">Graph</a>&amp; graph()</code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>The type to inspect.</td>
                </tr>
              </tbody>
            </table>
<p>This trait determines if the provided type <code>T</code> contains a member function with the exact signature <code><a href="classtf_1_1Graph.html" class="m-doc">tf::<wbr />Graph</a>&amp; graph()</code>. It uses SFINAE and <code>std::void_t</code> to detect the presence of the member function and its return type.</p><p>Example usage:</p><pre class="m-code"><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">graph</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">my_graph</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Graph</span><span class="w"> </span><span class="n">my_graph</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// other custom members to alter my_graph</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="p">{};</span><span class="w"> </span><span class="c1">// No graph function</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">has_graph_v</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A has graph()&quot;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">has_graph_v</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;C does not have graph()&quot;</span><span class="p">);</span></pre>
          </div></section>
          <section class="m-doc-details" id="a3d823d8776745f3348dc87bba2fcc91b"><div>
            <h3>
              <a href="http://en.cppreference.com/w/cpp/container/array.html" class="m-doc-external">std::<wbr />array</a>&lt;<a href="#a1355048578785a80414707ff308b395a" class="m-doc">TaskType</a>, 7&gt; tf::<wbr /><a href="#a3d823d8776745f3348dc87bba2fcc91b" class="m-doc-self">TASK_TYPES</a> <span class="m-label m-primary">constexpr</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="task_8hpp.html">&lt;taskflow/core/task.hpp&gt;</a></div>
            </h3>
            <p>array of all task types (used for iterating task types)</p>
          </div></section>
          <section class="m-doc-details" id="a11fc9c98eb3a0d3a9aa55598b1f4d614"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="task_8hpp.html">&lt;taskflow/core/task.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename C&gt;
              </div>
              bool tf::<wbr /><a href="#a11fc9c98eb3a0d3a9aa55598b1f4d614" class="m-doc-self">is_static_task_v</a> <span class="m-label m-primary">constexpr</span>
            </h3>
            <p>determines if a callable is a static task</p>
<p>A static task is a callable object constructible from std::function&lt;void()&gt;.</p>
          </div></section>
          <section class="m-doc-details" id="aefeb96086f4a99f0e58a0f321012a52c"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="task_8hpp.html">&lt;taskflow/core/task.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename C&gt;
              </div>
              bool tf::<wbr /><a href="#aefeb96086f4a99f0e58a0f321012a52c" class="m-doc-self">is_subflow_task_v</a> <span class="m-label m-primary">constexpr</span>
            </h3>
            <p>determines if a callable is a subflow task</p>
<p>A subflow task is a callable object constructible from std::function&lt;void(Subflow&amp;)&gt;.</p>
          </div></section>
          <section class="m-doc-details" id="af3d94f0be0f7b49e195c4e92737b1f85"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="task_8hpp.html">&lt;taskflow/core/task.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename C&gt;
              </div>
              bool tf::<wbr /><a href="#af3d94f0be0f7b49e195c4e92737b1f85" class="m-doc-self">is_runtime_task_v</a> <span class="m-label m-primary">constexpr</span>
            </h3>
            <p>determines if a callable is a runtime task</p>
<p>A runtime task is a callable object constructible from std::function&lt;void(Runtime&amp;)&gt;.</p>
          </div></section>
          <section class="m-doc-details" id="a00ca2fc2de0e679a7d9b8039340343df"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="task_8hpp.html">&lt;taskflow/core/task.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename C&gt;
              </div>
              bool tf::<wbr /><a href="#a00ca2fc2de0e679a7d9b8039340343df" class="m-doc-self">is_condition_task_v</a> <span class="m-label m-primary">constexpr</span>
            </h3>
            <p>determines if a callable is a condition task</p>
<p>A condition task is a callable object constructible from std::function&lt;int()&gt;.</p>
          </div></section>
          <section class="m-doc-details" id="a78c40dc8776735b0f2c27cd446481aff"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="task_8hpp.html">&lt;taskflow/core/task.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename C&gt;
              </div>
              bool tf::<wbr /><a href="#a78c40dc8776735b0f2c27cd446481aff" class="m-doc-self">is_multi_condition_task_v</a> <span class="m-label m-primary">constexpr</span>
            </h3>
            <p>determines if a callable is a multi-condition task</p>
<p>A multi-condition task is a callable object constructible from <a href="http://en.cppreference.com/w/cpp/utility/functional/function.html" class="m-doc-external">std::<wbr />function</a>&lt;tf::SmallVector&lt;int&gt;()&gt;.</p>
          </div></section>
          <section class="m-doc-details" id="a73c20705fc54763f195a00b6e626e301"><div>
            <h3>
              <div class="m-doc-include m-code m-inverted m-right-m m-text-right"><span class="cp">#include</span> <a class="cpf" href="partitioner_8hpp.html">&lt;taskflow/algorithm/partitioner.hpp&gt;</a></div>
              <div class="m-doc-template">
                template&lt;typename P&gt;
              </div>
              bool tf::<wbr /><a href="#a73c20705fc54763f195a00b6e626e301" class="m-doc-self">is_partitioner_v</a> <span class="m-label m-primary">constexpr</span>
            </h3>
            <p>determines if a type is a partitioner</p>
<p>A partitioner is a derived type from <a href="classtf_1_1PartitionerBase.html" class="m-doc">tf::<wbr />PartitionerBase</a>.</p>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Taskflow handbook is part of the <a href="https://taskflow.github.io">Taskflow project</a>, copyright © <a href="https://tsung-wei-huang.github.io/">Dr. Tsung-Wei Huang</a>, 2018&ndash;2025.<br />Generated by <a href="https://doxygen.org/">Doxygen</a> 1.9.1 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>

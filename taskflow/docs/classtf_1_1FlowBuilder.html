<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>tf::FlowBuilder class | Taskflow QuickStart</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://taskflow.github.io"><img src="taskflow_logo.png" alt="" />Taskflow</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">QuickStart</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Handbook</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="namespacetf.html">tf</a>::<wbr/></span>FlowBuilder <span class="m-thin">class</span>
          <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="flow__builder_8hpp.html">&lt;taskflow/core/flow_builder.hpp&gt;</a></div>
        </h1>
        <p>class to build a task dependency graph</p>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              Reference
              <ul>
                <li><a href="#derived-classes">Derived classes</a></li>
                <li><a href="#typeless-methods">Constructors, destructors, conversion operators</a></li>
                <li><a href="#pub-methods">Public functions</a></li>
                <li><a href="#pro-attribs">Protected variables</a></li>
              </ul>
            </li>
          </ul>
        </nav>
<p>The class provides essential methods to construct a task dependency graph from which <a href="classtf_1_1Taskflow.html" class="m-doc">tf::<wbr />Taskflow</a> and <a href="classtf_1_1Subflow.html" class="m-doc">tf::<wbr />Subflow</a> are derived.</p>
        <section id="derived-classes">
          <h2><a href="#derived-classes">Derived classes</a></h2>
          <dl class="m-doc">
            <dt>
              class <a href="classtf_1_1Subflow.html" class="m-doc">Subflow</a>
            </dt>
            <dd>class to construct a subflow graph from the execution of a dynamic task</dd>
            <dt>
              class <a href="classtf_1_1Taskflow.html" class="m-doc">Taskflow</a>
            </dt>
            <dd>class to create a taskflow object</dd>
          </dl>
        </section>
        <section id="typeless-methods">
          <h2><a href="#typeless-methods">Constructors, destructors, conversion operators</a></h2>
          <dl class="m-doc">
            <dt id="a67d023d5493da1594a1d2eaea89da179">
              <span class="m-doc-wrap-bumper"><a href="#a67d023d5493da1594a1d2eaea89da179" class="m-doc-self">FlowBuilder</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1Graph.html" class="m-doc">Graph</a>&amp; graph)</span>
            </dt>
            <dd>constructs a flow builder with a graph</dd>
          </dl>
        </section>
        <section id="pub-methods">
          <h2><a href="#pub-methods">Public functions</a></h2>
          <dl class="m-doc">
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a11fc9c98eb3a0d3a9aa55598b1f4d614" class="m-doc">is_<wbr />static_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a static task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#af3d94f0be0f7b49e195c4e92737b1f85" class="m-doc">is_<wbr />runtime_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a runtime task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#aefeb96086f4a99f0e58a0f321012a52c" class="m-doc">is_<wbr />subflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a dynamic task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a00ca2fc2de0e679a7d9b8039340343df" class="m-doc">is_<wbr />condition_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a condition task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a78c40dc8776735b0f2c27cd446481aff" class="m-doc">is_<wbr />multi_<wbr />condition_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a multi-condition task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename... C, std::enable_if_t&lt;(sizeof...(C)&gt;1), void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a1f6118326ad434f6c839007a1a79fe1b" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C &amp;&amp; ... callables) -&gt; auto</span>
            </dt>
            <dd>creates multiple tasks from a list of callable objects</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a5627f7962099ac7c4986993cffa7b909" class="m-doc">erase</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1Task.html" class="m-doc">Task</a> task)</span>
            </dt>
            <dd>removes a task from a taskflow</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ac6f22228d4c2ea2e643c4b0d42c0e92a" class="m-doc">composed_of</a>(</span><span class="m-doc-wrap">T&amp; object) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a module task for the target object</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#acab0b4ac82260f47fdb36a3244ee3aaf" class="m-doc">placeholder</a>(</span><span class="m-doc-wrap">) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a placeholder task</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a90f3d9b9d6fcf4df8e7d7878dfdd130d" class="m-doc">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/container/vector.html" class="m-doc-external">std::<wbr />vector</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt;&amp; tasks)</span>
            </dt>
            <dd>adds adjacent dependency links to a linear list of tasks</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a4ec89b554d15ad5fb96f4fdb10dbbb16" class="m-doc">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/utility/initializer_list.html" class="m-doc-external">std::<wbr />initializer_list</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt; tasks)</span>
            </dt>
            <dd>adds adjacent dependency links to a linear list of tasks</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename C, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#aae3edfa278baa75b08414e083c14c836" class="m-doc">for_each</a>(</span><span class="m-doc-wrap">B first,
              E last,
              C callable,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an STL-styled parallel-for task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename S, typename C, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a3b132bd902331a11b04b4ad66cf8bf77" class="m-doc">for_each_index</a>(</span><span class="m-doc-wrap">B first,
              E last,
              S step,
              C callable,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an index-based parallel-for task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename R, typename C, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a2582a216d54dacca2b7022ea7e89452a" class="m-doc">for_each_by_index</a>(</span><span class="m-doc-wrap">R range,
              C callable,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an index range-based parallel-for task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename O, typename C, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>, std::enable_if_t&lt;<a href="namespacetf.html#a73c20705fc54763f195a00b6e626e301" class="m-doc">is_<wbr />partitioner_<wbr />v</a>&lt;std::decay_t&lt;P&gt;&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a97be7ceef6fa4276e3b074c10c13b826" class="m-doc">transform</a>(</span><span class="m-doc-wrap">B first1,
              E last1,
              O d_first,
              C c,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a parallel-transform task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B1, typename E1, typename B2, typename O, typename C, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>, std::enable_if_t&lt;!<a href="namespacetf.html#a73c20705fc54763f195a00b6e626e301" class="m-doc">is_<wbr />partitioner_<wbr />v</a>&lt;std::decay_t&lt;C&gt;&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a7ea96d3fa0aa9e3ff337a9f1e37682b0" class="m-doc">transform</a>(</span><span class="m-doc-wrap">B1 first1,
              E1 last1,
              B2 first2,
              O d_first,
              C c,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a parallel-transform task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename O, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#afb24798ebf46e253a40b01bffb1da6a7" class="m-doc">reduce</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; init,
              O bop,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an STL-styled parallel-reduction task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename R, typename T, typename L, typename G, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a3ea810696c4b29824d1aaef15342c825" class="m-doc">reduce_by_index</a>(</span><span class="m-doc-wrap">R range,
              T&amp; init,
              L lop,
              G gop,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an index range-based parallel-reduction task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename BOP, typename UOP, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>, std::enable_if_t&lt;<a href="namespacetf.html#a73c20705fc54763f195a00b6e626e301" class="m-doc">is_<wbr />partitioner_<wbr />v</a>&lt;std::decay_t&lt;P&gt;&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#aa62d24438c0860e76153ffd129deba41" class="m-doc">transform_reduce</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; init,
              BOP bop,
              UOP uop,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an STL-styled parallel transform-reduce task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B1, typename E1, typename B2, typename T, typename BOP_R, typename BOP_T, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>, std::enable_if_t&lt;!<a href="namespacetf.html#a73c20705fc54763f195a00b6e626e301" class="m-doc">is_<wbr />partitioner_<wbr />v</a>&lt;std::decay_t&lt;BOP_T&gt;&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#adcd90e5b46299f4ccab33caf46edcbc0" class="m-doc">transform_reduce</a>(</span><span class="m-doc-wrap">B1 first1,
              E1 last1,
              B2 first2,
              T&amp; init,
              BOP_R bop_r,
              BOP_T bop_t,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an STL-styled parallel transform-reduce task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename D, typename BOP&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a1c2ace9290d83c2a006614a4d66ad588" class="m-doc">inclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              BOP bop) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates an STL-styled parallel inclusive-scan task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename D, typename BOP, typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a0b589a5bbf9b18e6484fa9e554d39a39" class="m-doc">inclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              BOP bop,
              T init) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates an STL-styled parallel inclusive-scan task with an initial value</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename D, typename T, typename BOP&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a4e0d618d8eb0b3b2e5e00443a10bf512" class="m-doc">exclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              T init,
              BOP bop) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates an STL-styled parallel exclusive-scan task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename D, typename BOP, typename UOP&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a82f3c3f49a2d52cd52f6eac07a659e9c" class="m-doc">transform_inclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              BOP bop,
              UOP uop) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates an STL-styled parallel transform-inclusive scan task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename D, typename BOP, typename UOP, typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a49f7e17d02c708035b9134d8c6c89f90" class="m-doc">transform_inclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              BOP bop,
              UOP uop,
              T init) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates an STL-styled parallel transform-inclusive scan task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename D, typename T, typename BOP, typename UOP&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a8549478ef819699b30f8daf88f04d577" class="m-doc">transform_exclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              T init,
              BOP bop,
              UOP uop) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates an STL-styled parallel transform-exclusive scan task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename UOP, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a46a96f5889e6ac87b1ff8d6313b5f471" class="m-doc">find_if</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; result,
              UOP predicate,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a task to perform STL-styled find-if algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename UOP, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a95fa2719fa7bbe7d171cf474ddb06726" class="m-doc">find_if_not</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; result,
              UOP predicate,
              P part = P()) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a task to perform STL-styled find-if-not algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename C, typename P&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a6bf43eeaa81900084a472be1d36d46a6" class="m-doc">min_element</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; result,
              C comp,
              P part) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a task to perform STL-styled min-element algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename C, typename P&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a6be5d7f053a868647c3b9e0d9cdf6b68" class="m-doc">max_element</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; result,
              C comp,
              P part) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a task to perform STL-styled max-element algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a35e180eb63de6c9f28e43185e837a4fa" class="m-doc">sort</a>(</span><span class="m-doc-wrap">B first,
              E last,
              C cmp) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a dynamic task to perform STL-styled parallel sort</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a7d844e9856c7c65b26ccdb83ffdab1d6" class="m-doc">sort</a>(</span><span class="m-doc-wrap">B first,
              E last) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a dynamic task to perform STL-styled parallel sort using the <code>std::less&lt;T&gt;</code> comparator, where <code>T</code> is the element type</dd>
          </dl>
        </section>
        <section id="pro-attribs">
          <h2><a href="#pro-attribs">Protected variables</a></h2>
          <dl class="m-doc">
            <dt id="a9404a57d9d37a4d49d20b686e4e5f68f">
              <a href="classtf_1_1Graph.html" class="m-doc">Graph</a>&amp; <a href="#a9404a57d9d37a4d49d20b686e4e5f68f" class="m-doc-self">_graph</a>
            </dt>
            <dd>associated graph object</dd>
          </dl>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a11fc9c98eb3a0d3a9aa55598b1f4d614" class="m-doc">is_<wbr />static_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a static task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void()&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a static task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a static task.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">static_task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){});</span></pre><p>Please refer to <a href="StaticTasking.html" class="m-doc">Static Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#af3d94f0be0f7b49e195c4e92737b1f85" class="m-doc">is_<wbr />runtime_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a runtime task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void(tf::Runtime&amp;)&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a runtime task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a runtime task.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">static_task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="p">){});</span></pre><p>Please refer to <a href="RuntimeTasking.html" class="m-doc">Runtime Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#aefeb96086f4a99f0e58a0f321012a52c" class="m-doc">is_<wbr />subflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a dynamic task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void(tf::Subflow&amp;)&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a dynamic task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a dynamic task (<a href="classtf_1_1Subflow.html" class="m-doc">tf::<wbr />Subflow</a>) that spawns two static tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">dynamic_task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Subflow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sf</span><span class="p">){</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">static_task1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sf</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){});</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">static_task2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sf</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){});</span>
<span class="p">});</span></pre><p>Please refer to <a href="SubflowTasking.html" class="m-doc">Subflow Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a00ca2fc2de0e679a7d9b8039340343df" class="m-doc">is_<wbr />condition_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a condition task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;int()&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a condition task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates an if-else block using one condition task and three static tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">taskflow</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="n">cond</span><span class="p">,</span><span class="w"> </span><span class="n">yes</span><span class="p">,</span><span class="w"> </span><span class="n">no</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;yes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;no</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>

<span class="c1">// executes yes if cond returns 0, or no if cond returns 1</span>
<span class="n">cond</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">yes</span><span class="p">,</span><span class="w"> </span><span class="n">no</span><span class="p">);</span>
<span class="n">cond</span><span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">init</span><span class="p">);</span></pre><p>Please refer to <a href="ConditionalTasking.html" class="m-doc">Conditional Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a78c40dc8776735b0f2c27cd446481aff" class="m-doc">is_<wbr />multi_<wbr />condition_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a multi-condition task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from <a href="http://en.cppreference.com/w/cpp/utility/functional/function.html" class="m-doc-external">std::<wbr />function</a>&lt;tf::SmallVector&lt;int&gt;()&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a multi-condition task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a multi-condition task that selectively jumps to two successor tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">taskflow</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="n">cond</span><span class="p">,</span><span class="w"> </span><span class="n">branch1</span><span class="p">,</span><span class="w"> </span><span class="n">branch2</span><span class="p">,</span><span class="w"> </span><span class="n">branch3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tf</span><span class="o">::</span><span class="n">SmallVector</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;branch1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;branch2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;branch3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>

<span class="c1">// executes branch1 and branch3 when cond returns 0 and 2</span>
<span class="n">cond</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">branch1</span><span class="p">,</span><span class="w"> </span><span class="n">branch2</span><span class="p">,</span><span class="w"> </span><span class="n">branch3</span><span class="p">);</span>
<span class="n">cond</span><span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">init</span><span class="p">);</span></pre><p>Please refer to <a href="ConditionalTasking.html" class="m-doc">Conditional Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a1f6118326ad434f6c839007a1a79fe1b"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename... C, std::enable_if_t&lt;(sizeof...(C)&gt;1), void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a1f6118326ad434f6c839007a1a79fe1b" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C &amp;&amp; ... callables)</span></span>
            </h3>
            <p>creates multiple tasks from a list of callable objects</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable types</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callables</td>
                  <td>one or multiple callable objects constructible from each task category</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The method returns a tuple of tasks each corresponding to the given callable target. You can use structured binding to get the return tasks one by one. The following example creates four static tasks and assign them to <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> using structured binding.</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span></pre>
          </div></section>
          <section class="m-doc-details" id="a5627f7962099ac7c4986993cffa7b909"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a5627f7962099ac7c4986993cffa7b909" class="m-doc-self">erase</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1Task.html" class="m-doc">Task</a> task)</span></span>
            </h3>
            <p>removes a task from a taskflow</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">task</td>
                  <td>task to remove</td>
                </tr>
              </tbody>
            </table>
<p>Removes a task and its input and output dependencies from the graph associated with the flow builder. If the task does not belong to the graph, nothing will happen.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">A</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span>

<span class="c1">// erase A from the taskflow and its dependencies to B, C, and D</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">A</span><span class="p">);</span></pre>
          </div></section>
          <section class="m-doc-details" id="ac6f22228d4c2ea2e643c4b0d42c0e92a"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ac6f22228d4c2ea2e643c4b0d42c0e92a" class="m-doc-self">composed_of</a>(</span><span class="m-doc-wrap">T&amp; object)</span></span>
            </h3>
            <p>creates a module task for the target object</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>target object type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>object</td>
                  <td>a custom object that defines the method <code>T::graph()</code></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The example below demonstrates a taskflow composition using the <code>composed_of</code> method.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span>
<span class="n">t1</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;t1&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>

<span class="c1">// t2 is partially composed of t1</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">comp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">composed_of</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;t2&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">init</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span></pre><p>The taskflow object <code>t2</code> is composed of another taskflow object <code>t1</code>, preceded by another static task <code>init</code>. When taskflow <code>t2</code> is submitted to an executor, <code>init</code> will run first and then <code>comp</code> which spawns its definition in taskflow <code>t1</code>.</p><p>The target <code>object</code> being composed must define the method <code>T::graph()</code> that returns a reference to a graph object of type <a href="classtf_1_1Graph.html" class="m-doc">tf::<wbr />Graph</a> such that it can interact with the executor. For example:</p><pre class="m-code"><span class="c1">// custom struct</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyObj</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Graph</span><span class="w"> </span><span class="n">graph</span><span class="p">;</span>
<span class="w">  </span><span class="n">MyObj</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tf</span><span class="o">::</span><span class="n">FlowBuilder</span><span class="w"> </span><span class="nf">builder</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span>
<span class="w">    </span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a task</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w">  </span><span class="c1">// static task</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="n">graph</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">graph</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">MyObj</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">comp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">composed_of</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span></pre><p>Please refer to <a href="ComposableTasking.html" class="m-doc">Composable Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="acab0b4ac82260f47fdb36a3244ee3aaf"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#acab0b4ac82260f47fdb36a3244ee3aaf" class="m-doc-self">placeholder</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>creates a placeholder task</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>A placeholder task maps to a node in the taskflow graph, but it does not have any callable work assigned yet. A placeholder task is different from an empty task handle that does not point to any node in a graph.</p><pre class="m-code"><span class="c1">// create a placeholder task with no callable target assigned</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">placeholder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">placeholder</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="n">placeholder</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">placeholder</span><span class="p">.</span><span class="n">has_work</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="c1">// create an empty task handle</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">task</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="c1">// assign the task handle to the placeholder task</span>
<span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">placeholder</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">has_work</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span></pre>
          </div></section>
          <section class="m-doc-details" id="a90f3d9b9d6fcf4df8e7d7878dfdd130d"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a90f3d9b9d6fcf4df8e7d7878dfdd130d" class="m-doc-self">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/container/vector.html" class="m-doc-external">std::<wbr />vector</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt;&amp; tasks)</span></span>
            </h3>
            <p>adds adjacent dependency links to a linear list of tasks</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">tasks</td>
                  <td>a vector of tasks</td>
                </tr>
              </tbody>
            </table>
<p>This member function creates linear dependencies over a vector of tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tasks</span><span class="w"> </span><span class="p">{</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">}</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span><span class="w">  </span><span class="c1">// A-&gt;B-&gt;C-&gt;D</span></pre>
          </div></section>
          <section class="m-doc-details" id="a4ec89b554d15ad5fb96f4fdb10dbbb16"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a4ec89b554d15ad5fb96f4fdb10dbbb16" class="m-doc-self">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/utility/initializer_list.html" class="m-doc-external">std::<wbr />initializer_list</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt; tasks)</span></span>
            </h3>
            <p>adds adjacent dependency links to a linear list of tasks</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">tasks</td>
                  <td>an initializer list of tasks</td>
                </tr>
              </tbody>
            </table>
<p>This member function creates linear dependencies over a list of tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">linearize</span><span class="p">({</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">});</span><span class="w">  </span><span class="c1">// A-&gt;B-&gt;C-&gt;D</span></pre>
          </div></section>
          <section class="m-doc-details" id="aae3edfa278baa75b08414e083c14c836"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename C, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aae3edfa278baa75b08414e083c14c836" class="m-doc-self">for_each</a>(</span><span class="m-doc-wrap">B first,
              E last,
              C callable,
              P part = P())</span></span>
            </h3>
            <p>constructs an STL-styled parallel-for task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>callable object to apply to the dereferenced iterator</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm to schedule parallel iterations</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns asynchronous tasks that applies the callable object to each object obtained by dereferencing every iterator in the range <code>[first, last)</code>. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">itr</span><span class="o">=</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">!=</span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">callable</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">);</span>
<span class="p">}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a> The callable needs to take a single argument of the dereferenced iterator type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a3b132bd902331a11b04b4ad66cf8bf77"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename S, typename C, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a3b132bd902331a11b04b4ad66cf8bf77" class="m-doc-self">for_each_index</a>(</span><span class="m-doc-wrap">B first,
              E last,
              S step,
              C callable,
              P part = P())</span></span>
            </h3>
            <p>constructs an index-based parallel-for task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning index type (must be integral)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending index type (must be integral)</td>
                </tr>
                <tr>
                  <td>S</td>
                  <td>step type (must be integral)</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>index of the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>index of the end (exclusive)</td>
                </tr>
                <tr>
                  <td>step</td>
                  <td>step size</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>callable object to apply to each valid index</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm to schedule parallel iterations</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns asynchronous tasks that applies the callable object to each index in the range <code>[first, last)</code> with the step size. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="c1">// case 1: step size is positive</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="n">step</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">callable</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// case 2: step size is negative</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="n">step</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">callable</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a> The callable needs to take a single argument of the integral index type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a2582a216d54dacca2b7022ea7e89452a"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename R, typename C, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a2582a216d54dacca2b7022ea7e89452a" class="m-doc-self">for_each_by_index</a>(</span><span class="m-doc-wrap">R range,
              C callable,
              P part = P())</span></span>
            </h3>
            <p>constructs an index range-based parallel-for task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">R</td>
                  <td>index range type (<a href="classtf_1_1IndexRange.html" class="m-doc">tf::<wbr />IndexRange</a>)</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>range</td>
                  <td>index range</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>callable object to apply to each valid index</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm to schedule parallel iterations</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns asynchronous tasks that applies the callable object to in the range <code>[first, last)</code> with the step size.</p><pre class="m-code"><span class="c1">// [0, 17) with a step size of 2 using tf::IndexRange</span>
<span class="n">tf</span><span class="o">::</span><span class="n">IndexRange</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// parallelize the sequence [0, 2, 4, 6, 8, 10, 12, 14, 16]</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">for_each_by_index</span><span class="p">(</span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">tf</span><span class="o">::</span><span class="n">IndexRange</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">range</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// iterate each index in the subrange</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">range</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">range</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="n">range</span><span class="p">.</span><span class="n">step_size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;iterate %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">});</span>

<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span></pre><p>The callable needs to take a single argument of type <a href="classtf_1_1IndexRange.html" class="m-doc">tf::<wbr />IndexRange</a>.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a97be7ceef6fa4276e3b074c10c13b826"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename O, typename C, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>, std::enable_if_t&lt;<a href="namespacetf.html#a73c20705fc54763f195a00b6e626e301" class="m-doc">is_<wbr />partitioner_<wbr />v</a>&lt;std::decay_t&lt;P&gt;&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a97be7ceef6fa4276e3b074c10c13b826" class="m-doc-self">transform</a>(</span><span class="m-doc-wrap">B first1,
              E last1,
              O d_first,
              C c,
              P part = P())</span></span>
            </h3>
            <p>constructs a parallel-transform task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning input iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending input iterator type</td>
                </tr>
                <tr>
                  <td>O</td>
                  <td>output iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first1</td>
                  <td>iterator to the beginning of the first range</td>
                </tr>
                <tr>
                  <td>last1</td>
                  <td>iterator to the end of the first range</td>
                </tr>
                <tr>
                  <td>d_first</td>
                  <td>iterator to the beginning of the output range</td>
                </tr>
                <tr>
                  <td>c</td>
                  <td>an unary callable to apply to dereferenced input elements</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm to schedule parallel iterations</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns asynchronous tasks that applies the callable object to an input range and stores the result in another output range. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">first1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">*</span><span class="n">d_first</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="o">*</span><span class="n">first1</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a> The callable needs to take a single argument of the dereferenced iterator type.</p><p>Please refer to <a href="ParallelTransforms.html" class="m-doc">Parallel Transforms</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a7ea96d3fa0aa9e3ff337a9f1e37682b0"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B1, typename E1, typename B2, typename O, typename C, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>, std::enable_if_t&lt;!<a href="namespacetf.html#a73c20705fc54763f195a00b6e626e301" class="m-doc">is_<wbr />partitioner_<wbr />v</a>&lt;std::decay_t&lt;C&gt;&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a7ea96d3fa0aa9e3ff337a9f1e37682b0" class="m-doc-self">transform</a>(</span><span class="m-doc-wrap">B1 first1,
              E1 last1,
              B2 first2,
              O d_first,
              C c,
              P part = P())</span></span>
            </h3>
            <p>constructs a parallel-transform task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B1</td>
                  <td>beginning input iterator type for the first input range</td>
                </tr>
                <tr>
                  <td>E1</td>
                  <td>ending input iterator type for the first input range</td>
                </tr>
                <tr>
                  <td>B2</td>
                  <td>beginning input iterator type for the first second range</td>
                </tr>
                <tr>
                  <td>O</td>
                  <td>output iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first1</td>
                  <td>iterator to the beginning of the first input range</td>
                </tr>
                <tr>
                  <td>last1</td>
                  <td>iterator to the end of the first input range</td>
                </tr>
                <tr>
                  <td>first2</td>
                  <td>iterator to the beginning of the second input range</td>
                </tr>
                <tr>
                  <td>d_first</td>
                  <td>iterator to the beginning of the output range</td>
                </tr>
                <tr>
                  <td>c</td>
                  <td>a binary operator to apply to dereferenced input elements</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm to schedule parallel iterations</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns asynchronous tasks that applies the callable object to two input ranges and stores the result in another output range. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">first1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">*</span><span class="n">d_first</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="o">*</span><span class="n">first1</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">first2</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a> The callable needs to take two arguments of dereferenced elements from the two input ranges.</p><p>Please refer to <a href="ParallelTransforms.html" class="m-doc">Parallel Transforms</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="afb24798ebf46e253a40b01bffb1da6a7"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename O, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#afb24798ebf46e253a40b01bffb1da6a7" class="m-doc-self">reduce</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; init,
              O bop,
              P part = P())</span></span>
            </h3>
            <p>constructs an STL-styled parallel-reduction task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>O</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm to schedule parallel iterations</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns asynchronous tasks to perform parallel reduction over <code>init</code> and the elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">itr</span><span class="o">=</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">!=</span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bop</span><span class="p">(</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">itr</span><span class="p">);</span>
<span class="p">}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a3ea810696c4b29824d1aaef15342c825"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename R, typename T, typename L, typename G, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a3ea810696c4b29824d1aaef15342c825" class="m-doc-self">reduce_by_index</a>(</span><span class="m-doc-wrap">R range,
              T&amp; init,
              L lop,
              G gop,
              P part = P())</span></span>
            </h3>
            <p>constructs an index range-based parallel-reduction task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">R</td>
                  <td>index range type (<a href="classtf_1_1IndexRange.html" class="m-doc">tf::<wbr />IndexRange</a>)</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>L</td>
                  <td>local reducer type</td>
                </tr>
                <tr>
                  <td>G</td>
                  <td>global reducer type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>range</td>
                  <td>index range</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>lop</td>
                  <td>binary operator that will be applied locally per worker</td>
                </tr>
                <tr>
                  <td>gop</td>
                  <td>binary operator that will be applied globally among worker</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm to schedule parallel iterations</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns asynchronous tasks to perform parallel reduction over a range with <code>init</code>. The reduced result is store in <code>init</code>. Unlike the iterator-based reduction, index range-based reduction is particularly useful for applications that benefit from SIMD optimizations or other range-based processing strategies.</p><pre class="m-code"><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000000</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">N</span><span class="p">);</span><span class="w">  </span><span class="c1">// uninitialized data vector</span>
<span class="kt">int</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">               </span><span class="c1">// res will participate in the reduction</span>

<span class="n">taskflow</span><span class="p">.</span><span class="n">reduce_by_index</span><span class="p">(</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">IndexRange</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span>
<span class="w">  </span><span class="c1">// final result</span>
<span class="w">  </span><span class="n">res</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// local reducer</span>
<span class="w">  </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">IndexRange</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">subrange</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">running_total</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">residual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">running_total</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">*</span><span class="n">running_total</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">subrange</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">subrange</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="n">subrange</span><span class="p">.</span><span class="n">step_size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">      </span><span class="n">residual</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;partial sum = %lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">residual</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">residual</span><span class="p">;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="c1">// global reducer</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span></pre><p>Range can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="aa62d24438c0860e76153ffd129deba41"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename BOP, typename UOP, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>, std::enable_if_t&lt;<a href="namespacetf.html#a73c20705fc54763f195a00b6e626e301" class="m-doc">is_<wbr />partitioner_<wbr />v</a>&lt;std::decay_t&lt;P&gt;&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aa62d24438c0860e76153ffd129deba41" class="m-doc-self">transform_reduce</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; init,
              BOP bop,
              UOP uop,
              P part = P())</span></span>
            </h3>
            <p>constructs an STL-styled parallel transform-reduce task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>unary transformation type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied in unspecified order to the results of <code>uop</code></td>
                </tr>
                <tr>
                  <td>uop</td>
                  <td>unary operator that will be applied to transform each element in the range to the result type</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm to schedule parallel iterations</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns asynchronous tasks to perform parallel reduction over <code>init</code> and the transformed elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">itr</span><span class="o">=</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">!=</span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bop</span><span class="p">(</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="n">uop</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">));</span>
<span class="p">}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="adcd90e5b46299f4ccab33caf46edcbc0"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B1, typename E1, typename B2, typename T, typename BOP_R, typename BOP_T, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>, std::enable_if_t&lt;!<a href="namespacetf.html#a73c20705fc54763f195a00b6e626e301" class="m-doc">is_<wbr />partitioner_<wbr />v</a>&lt;std::decay_t&lt;BOP_T&gt;&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#adcd90e5b46299f4ccab33caf46edcbc0" class="m-doc-self">transform_reduce</a>(</span><span class="m-doc-wrap">B1 first1,
              E1 last1,
              B2 first2,
              T&amp; init,
              BOP_R bop_r,
              BOP_T bop_t,
              P part = P())</span></span>
            </h3>
            <p>constructs an STL-styled parallel transform-reduce task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B1</td>
                  <td>first beginning iterator type</td>
                </tr>
                <tr>
                  <td>E1</td>
                  <td>first ending iterator type</td>
                </tr>
                <tr>
                  <td>B2</td>
                  <td>second beginning iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>BOP_R</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>BOP_T</td>
                  <td>binary transformation type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first1</td>
                  <td>iterator to the beginning of the first range (inclusive)</td>
                </tr>
                <tr>
                  <td>last1</td>
                  <td>iterator to the end of the first range (exclusive)</td>
                </tr>
                <tr>
                  <td>first2</td>
                  <td>iterator to the beginning of the second range</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop_r</td>
                  <td>binary operator that will be applied in unspecified order to the results of <code>bop_t</code></td>
                </tr>
                <tr>
                  <td>bop_t</td>
                  <td>binary operator that will be applied to transform each element in the range to the result type</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm to schedule parallel iterations</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns asynchronous tasks to perform parallel reduction over <code>init</code> and transformed elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">itr1</span><span class="o">=</span><span class="n">first1</span><span class="p">,</span><span class="w"> </span><span class="n">itr2</span><span class="o">=</span><span class="n">first2</span><span class="p">;</span><span class="w"> </span><span class="n">itr1</span><span class="o">!=</span><span class="n">last1</span><span class="p">;</span><span class="w"> </span><span class="n">itr1</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">itr2</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bop_r</span><span class="p">(</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="n">bop_t</span><span class="p">(</span><span class="o">*</span><span class="n">itr1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">itr2</span><span class="p">));</span>
<span class="p">}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a1c2ace9290d83c2a006614a4d66ad588"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename D, typename BOP&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a1c2ace9290d83c2a006614a4d66ad588" class="m-doc-self">inclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              BOP bop)</span></span>
            </h3>
            <p>creates an STL-styled parallel inclusive-scan task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>D</td>
                  <td>destination iterator type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>summation operator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>start of input range</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>end of input range</td>
                </tr>
                <tr>
                  <td>d_first</td>
                  <td>start of output range (may be the same as input range)</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>function to perform summation</td>
                </tr>
              </tbody>
            </table>
<p>Performs the cumulative sum (aka prefix sum, aka scan) of the input range and writes the result to the output range. Each element of the output range contains the running total of all earlier elements using the given binary operator for summation.</p><p>This function generates an <em>inclusive</em> scan, meaning that the N-th element of the output range is the sum of the first N input elements, so the N-th input element is included.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">inclusive_scan</span><span class="p">(</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>

<span class="c1">// input is {1, 3, 6, 10, 15}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelScan.html" class="m-doc">Parallel Scan</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a0b589a5bbf9b18e6484fa9e554d39a39"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename D, typename BOP, typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a0b589a5bbf9b18e6484fa9e554d39a39" class="m-doc-self">inclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              BOP bop,
              T init)</span></span>
            </h3>
            <p>creates an STL-styled parallel inclusive-scan task with an initial value</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>D</td>
                  <td>destination iterator type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>summation operator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>initial value type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>start of input range</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>end of input range</td>
                </tr>
                <tr>
                  <td>d_first</td>
                  <td>start of output range (may be the same as input range)</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>function to perform summation</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value</td>
                </tr>
              </tbody>
            </table>
<p>Performs the cumulative sum (aka prefix sum, aka scan) of the input range and writes the result to the output range. Each element of the output range contains the running total of all earlier elements (and the initial value) using the given binary operator for summation.</p><p>This function generates an <em>inclusive</em> scan, meaning the N-th element of the output range is the sum of the first N input elements, so the N-th input element is included.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">inclusive_scan</span><span class="p">(</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="mi">-1</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>

<span class="c1">// input is {0, 2, 5, 9, 14}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelScan.html" class="m-doc">Parallel Scan</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a4e0d618d8eb0b3b2e5e00443a10bf512"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename D, typename T, typename BOP&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a4e0d618d8eb0b3b2e5e00443a10bf512" class="m-doc-self">exclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              T init,
              BOP bop)</span></span>
            </h3>
            <p>creates an STL-styled parallel exclusive-scan task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>D</td>
                  <td>destination iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>initial value type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>summation operator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>start of input range</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>end of input range</td>
                </tr>
                <tr>
                  <td>d_first</td>
                  <td>start of output range (may be the same as input range)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>function to perform summation</td>
                </tr>
              </tbody>
            </table>
<p>Performs the cumulative sum (aka prefix sum, aka scan) of the input range and writes the result to the output range. Each element of the output range contains the running total of all earlier elements (and the initial value) using the given binary operator for summation.</p><p>This function generates an <em>exclusive</em> scan, meaning the N-th element of the output range is the sum of the first N-1 input elements, so the N-th input element is not included.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">exclusive_scan</span><span class="p">(</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>

<span class="c1">// input is {-1, 0, 2, 5, 9}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelScan.html" class="m-doc">Parallel Scan</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a82f3c3f49a2d52cd52f6eac07a659e9c"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename D, typename BOP, typename UOP&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a82f3c3f49a2d52cd52f6eac07a659e9c" class="m-doc-self">transform_inclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              BOP bop,
              UOP uop)</span></span>
            </h3>
            <p>creates an STL-styled parallel transform-inclusive scan task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>D</td>
                  <td>destination iterator type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>summation operator type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>transform operator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>start of input range</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>end of input range</td>
                </tr>
                <tr>
                  <td>d_first</td>
                  <td>start of output range (may be the same as input range)</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>function to perform summation</td>
                </tr>
                <tr>
                  <td>uop</td>
                  <td>function to transform elements of the input range</td>
                </tr>
              </tbody>
            </table>
<p>Write the cumulative sum (aka prefix sum, aka scan) of the input range to the output range. Each element of the output range contains the running total of all earlier elements using <code>uop</code> to transform the input elements and using <code>bop</code> for summation.</p><p>This function generates an <em>inclusive</em> scan, meaning the Nth element of the output range is the sum of the first N input elements, so the Nth input element is included.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">transform_inclusive_scan</span><span class="p">(</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">item</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>

<span class="c1">// input is {-1, -3, -6, -10, -15}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelScan.html" class="m-doc">Parallel Scan</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a49f7e17d02c708035b9134d8c6c89f90"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename D, typename BOP, typename UOP, typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a49f7e17d02c708035b9134d8c6c89f90" class="m-doc-self">transform_inclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              BOP bop,
              UOP uop,
              T init)</span></span>
            </h3>
            <p>creates an STL-styled parallel transform-inclusive scan task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>D</td>
                  <td>destination iterator type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>summation operator type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>transform operator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>initial value type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>start of input range</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>end of input range</td>
                </tr>
                <tr>
                  <td>d_first</td>
                  <td>start of output range (may be the same as input range)</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>function to perform summation</td>
                </tr>
                <tr>
                  <td>uop</td>
                  <td>function to transform elements of the input range</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value</td>
                </tr>
              </tbody>
            </table>
<p>Write the cumulative sum (aka prefix sum, aka scan) of the input range to the output range. Each element of the output range contains the running total of all earlier elements (including an initial value) using <code>uop</code> to transform the input elements and using <code>bop</code> for summation.</p><p>This function generates an <em>inclusive</em> scan, meaning the Nth element of the output range is the sum of the first N input elements, so the Nth input element is included.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">transform_inclusive_scan</span><span class="p">(</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">item</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="mi">-1</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>

<span class="c1">// input is {-2, -4, -7, -11, -16}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelScan.html" class="m-doc">Parallel Scan</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a8549478ef819699b30f8daf88f04d577"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename D, typename T, typename BOP, typename UOP&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a8549478ef819699b30f8daf88f04d577" class="m-doc-self">transform_exclusive_scan</a>(</span><span class="m-doc-wrap">B first,
              E last,
              D d_first,
              T init,
              BOP bop,
              UOP uop)</span></span>
            </h3>
            <p>creates an STL-styled parallel transform-exclusive scan task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>D</td>
                  <td>destination iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>initial value type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>summation operator type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>transform operator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>start of input range</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>end of input range</td>
                </tr>
                <tr>
                  <td>d_first</td>
                  <td>start of output range (may be the same as input range)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>function to perform summation</td>
                </tr>
                <tr>
                  <td>uop</td>
                  <td>function to transform elements of the input range</td>
                </tr>
              </tbody>
            </table>
<p>Write the cumulative sum (aka prefix sum, aka scan) of the input range to the output range. Each element of the output range contains the running total of all earlier elements (including an initial value) using <code>uop</code> to transform the input elements and using <code>bop</code> for summation.</p><p>This function generates an <em>exclusive</em> scan, meaning the Nth element of the output range is the sum of the first N-1 input elements, so the Nth input element is not included.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">transform_exclusive_scan</span><span class="p">(</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{},</span>
<span class="w">  </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">item</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>

<span class="c1">// input is {-1, -2, -4, -7, -11}</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelScan.html" class="m-doc">Parallel Scan</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a46a96f5889e6ac87b1ff8d6313b5f471"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename UOP, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a46a96f5889e6ac87b1ff8d6313b5f471" class="m-doc-self">find_if</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; result,
              UOP predicate,
              P part = P())</span></span>
            </h3>
            <p>constructs a task to perform STL-styled find-if algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>resulting iterator type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>unary predicate type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>start of the input range</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>end of the input range</td>
                </tr>
                <tr>
                  <td>result</td>
                  <td>resulting iterator to the found element in the input range</td>
                </tr>
                <tr>
                  <td>predicate</td>
                  <td>unary predicate which returns <code>true</code> for the required element</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
            </table>
<p>Returns an iterator to the first element in the range <code>[first, last)</code> that satisfies the given criteria (or last if there is no such iterator). This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">find_if</span><span class="p">(</span><span class="n">InputIt</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">InputIt</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">UnaryPredicate</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">)){</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span></pre><p>For example, the code below find the element that satisfies the given criteria (value plus one is equal to 23) from an input range of 10 elements:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">find_if</span><span class="p">(</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">result</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">22</span><span class="p">);</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p>
          </div></section>
          <section class="m-doc-details" id="a95fa2719fa7bbe7d171cf474ddb06726"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename UOP, typename P = <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">DefaultPartitioner</a>&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a95fa2719fa7bbe7d171cf474ddb06726" class="m-doc-self">find_if_not</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; result,
              UOP predicate,
              P part = P())</span></span>
            </h3>
            <p>constructs a task to perform STL-styled find-if-not algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>resulting iterator type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>unary predicate type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>start of the input range</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>end of the input range</td>
                </tr>
                <tr>
                  <td>result</td>
                  <td>resulting iterator to the found element in the input range</td>
                </tr>
                <tr>
                  <td>predicate</td>
                  <td>unary predicate which returns <code>false</code> for the required element</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
            </table>
<p>Returns an iterator to the first element in the range <code>[first, last)</code> that satisfies the given criteria (or last if there is no such iterator). This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">find_if</span><span class="p">(</span><span class="n">InputIt</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">InputIt</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">UnaryPredicate</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">predicate</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">)){</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span></pre><p>For example, the code below find the element that satisfies the given criteria (value is not equal to 1) from an input range of 10 elements:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">find_if_not</span><span class="p">(</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">result</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">22</span><span class="p">);</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p>
          </div></section>
          <section class="m-doc-details" id="a6bf43eeaa81900084a472be1d36d46a6"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename C, typename P&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a6bf43eeaa81900084a472be1d36d46a6" class="m-doc-self">min_element</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; result,
              C comp,
              P part)</span></span>
            </h3>
            <p>constructs a task to perform STL-styled min-element algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>resulting iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>comparator type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>start of the input range</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>end of the input range</td>
                </tr>
                <tr>
                  <td>result</td>
                  <td>resulting iterator to the found element in the input range</td>
                </tr>
                <tr>
                  <td>comp</td>
                  <td>comparison function object</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
            </table>
<p>Finds the smallest element in the <code>[first, last)</code> using the given comparison function object. The iterator to that smallest element is stored in <code>result</code>. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">last</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">auto</span><span class="w"> </span><span class="n">smallest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="o">++</span><span class="n">first</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">comp</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">smallest</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">smallest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span><span class="w"> </span><span class="n">smallest</span><span class="p">;</span></pre><p>For example, the code below find the smallest element from an input range of 10 elements.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">min_element</span><span class="p">(</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">result</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p>
          </div></section>
          <section class="m-doc-details" id="a6be5d7f053a868647c3b9e0d9cdf6b68"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename C, typename P&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a6be5d7f053a868647c3b9e0d9cdf6b68" class="m-doc-self">max_element</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; result,
              C comp,
              P part)</span></span>
            </h3>
            <p>constructs a task to perform STL-styled max-element algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>resulting iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>comparator type</td>
                </tr>
                <tr>
                  <td>P</td>
                  <td>partitioner type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>start of the input range</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>end of the input range</td>
                </tr>
                <tr>
                  <td>result</td>
                  <td>resulting iterator to the found element in the input range</td>
                </tr>
                <tr>
                  <td>comp</td>
                  <td>comparison function object</td>
                </tr>
                <tr>
                  <td>part</td>
                  <td>partitioning algorithm (default <a href="namespacetf.html#a66b72776c788898aee9e132b0ea9b405" class="m-doc">tf::<wbr />DefaultPartitioner</a>)</td>
                </tr>
              </tbody>
            </table>
<p>Finds the largest element in the <code>[first, last)</code> using the given comparison function object. The iterator to that largest element is stored in <code>result</code>. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">last</span><span class="p">){</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">auto</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="o">++</span><span class="n">first</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">comp</span><span class="p">(</span><span class="o">*</span><span class="n">largest</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span><span class="w"> </span><span class="n">largest</span><span class="p">;</span></pre><p>For example, the code below find the largest element from an input range of 10 elements.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">max_element</span><span class="p">(</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">result</span>
<span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span></pre><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p>
          </div></section>
          <section class="m-doc-details" id="a35e180eb63de6c9f28e43185e837a4fa"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a35e180eb63de6c9f28e43185e837a4fa" class="m-doc-self">sort</a>(</span><span class="m-doc-wrap">B first,
              E last,
              C cmp)</span></span>
            </h3>
            <p>constructs a dynamic task to perform STL-styled parallel sort</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type (random-accessible)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type (random-accessible)</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>comparator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>cmp</td>
                  <td>comparison operator</td>
                </tr>
              </tbody>
            </table>
<p>The task spawns asynchronous tasks to sort elements in the range <code>[first, last)</code> in parallel.</p><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelSort.html" class="m-doc">Parallel Sort</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a7d844e9856c7c65b26ccdb83ffdab1d6"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a7d844e9856c7c65b26ccdb83ffdab1d6" class="m-doc-self">sort</a>(</span><span class="m-doc-wrap">B first,
              E last)</span></span>
            </h3>
            <p>constructs a dynamic task to perform STL-styled parallel sort using the <code>std::less&lt;T&gt;</code> comparator, where <code>T</code> is the element type</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type (random-accessible)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type (random-accessible)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
            </table>
<p>The task spawns asynchronous tasks to parallel sort elements in the range <code>[first, last)</code> using the <code>std::less&lt;T&gt;</code> comparator, where <code>T</code> is the dereferenced iterator type.</p><p>Iterators can be made stateful by using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a></p><p>Please refer to <a href="ParallelSort.html" class="m-doc">Parallel Sort</a> for details.</p>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Taskflow handbook is part of the <a href="https://taskflow.github.io">Taskflow project</a>, copyright © <a href="https://tsung-wei-huang.github.io/">Dr. Tsung-Wei Huang</a>, 2018&ndash;2025.<br />Generated by <a href="https://doxygen.org/">Doxygen</a> 1.9.1 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
